<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Musify â€” Player</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Musify">
    <link rel="manifest" href="/static/manifest.json">
    <link rel="apple-touch-icon" href="/static/icon-192.png">
    
    <!-- Socket.IO for Live Radio -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            height: -webkit-fill-available;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow-x: hidden;
            color: #fff;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            user-select: none;
        }

        /* Smooth scrolling */
        * {
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }

        *::-webkit-scrollbar {
            width: 4px;
        }

        *::-webkit-scrollbar-track {
            background: transparent;
        }

        *::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }

        /* Ambient Background */
        .ambient-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            transition: all 1.5s ease;
            filter: blur(120px) saturate(1.8);
            opacity: 0.5;
            transform: scale(1.5);
        }

        .ambient-bg img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Main Container */
        .player-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            position: relative;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 32px;
            position: relative;
            z-index: 10;
            flex-shrink: 0;
        }

        .header-title {
            font-size: 20px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.9;
        }

        .header-nav {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .header-nav a, .header-nav button {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
        }

        .header-nav a:hover, .header-nav button:hover {
            background: rgba(255,255,255,0.2);
        }

        .header-nav .active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        /* Install Button */
        .install-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%) !important;
            animation: pulse-install 2s infinite;
        }

        .install-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
        }

        .install-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        @keyframes pulse-install {
            0%, 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.4); }
            50% { box-shadow: 0 0 0 8px rgba(34, 197, 94, 0); }
        }

        /* PWA Install Banner */
        .pwa-install-banner {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.95) 0%, rgba(22, 163, 74, 0.95) 100%);
            backdrop-filter: blur(10px);
            padding: 16px 24px;
            border-radius: 16px;
            display: none;
            align-items: center;
            gap: 16px;
            z-index: 10000;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 90%;
            width: 400px;
        }

        .pwa-install-banner.visible {
            display: flex;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .pwa-install-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .pwa-install-icon svg {
            width: 28px;
            height: 28px;
            fill: #fff;
        }

        .pwa-install-content {
            flex: 1;
        }

        .pwa-install-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 2px;
        }

        .pwa-install-desc {
            font-size: 13px;
            color: rgba(255,255,255,0.8);
        }

        .pwa-install-actions {
            display: flex;
            gap: 8px;
        }

        .pwa-install-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .pwa-install-btn.primary {
            background: #fff;
            color: #16a34a;
        }

        .pwa-install-btn.primary:hover {
            transform: scale(1.05);
        }

        .pwa-install-btn.secondary {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        .pwa-install-btn.secondary:hover {
            background: rgba(255,255,255,0.3);
        }

        /* Search Button */
        .search-nav-btn {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .search-nav-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        /* Stream Toggle */
        .stream-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            font-size: 12px;
        }

        .stream-toggle-label {
            opacity: 0.7;
        }

        .stream-toggle-switch {
            position: relative;
            width: 40px;
            height: 22px;
            cursor: pointer;
        }

        .stream-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .stream-toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 22px;
            transition: all 0.3s ease;
        }

        .stream-toggle-slider:before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            left: 2px;
            bottom: 2px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .stream-toggle-switch input:checked + .stream-toggle-slider {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        }

        .stream-toggle-switch input:checked + .stream-toggle-slider:before {
            transform: translateX(18px);
        }

        .stream-indicator {
            display: none;
            align-items: center;
            gap: 4px;
            color: #22c55e;
            font-size: 11px;
            font-weight: 600;
        }

        .stream-indicator.active {
            display: flex;
        }

        .stream-indicator::before {
            content: '';
            width: 6px;
            height: 6px;
            background: #22c55e;
            border-radius: 50%;
            animation: pulse-live 1.5s infinite;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 4px;
            background: rgba(0,0,0,0.3);
            padding: 4px;
            border-radius: 12px;
            margin-right: 12px;
        }

        .tab-btn {
            padding: 8px 16px !important;
            border-radius: 8px !important;
            font-size: 13px !important;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tab-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .tab-btn.active {
            background: rgba(255,255,255,0.15) !important;
        }

        /* Search Page Overlay */
        .search-page {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            z-index: 100;
            display: none;
            flex-direction: column;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
        }

        .search-page.visible {
            display: flex;
            opacity: 1;
            transform: translateY(0);
        }

        .search-header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 20px 32px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }

        .search-back-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-back-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .search-back-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .search-input-container {
            flex: 1;
            position: relative;
        }

        .search-input-large {
            width: 100%;
            padding: 14px 20px 14px 48px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 30px;
            color: #fff;
            font-size: 16px;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-input-large:focus {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.2);
        }

        .search-input-large::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .search-input-icon {
            position: absolute;
            left: 18px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            fill: rgba(255,255,255,0.5);
        }

        .search-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px 32px;
        }

        .search-section-title {
            font-size: 14px;
            font-weight: 600;
            opacity: 0.6;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .search-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 16px;
        }

        .search-result-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .search-result-card:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.1);
            transform: translateY(-2px);
        }

        .search-result-thumb {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 8px;
            object-fit: cover;
            margin-bottom: 10px;
        }

        .search-result-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-result-artist {
            font-size: 12px;
            opacity: 0.6;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-result-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .search-action-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.2s ease;
        }

        .search-action-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        .search-action-play {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .search-action-play:hover {
            transform: scale(1.02);
        }

        .search-action-download {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .search-action-download:hover {
            background: rgba(255,255,255,0.2);
        }

        .search-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            flex-direction: column;
            gap: 16px;
        }

        .search-loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Up Next / Similar Songs Panel */
        .upnext-panel {
            position: fixed;
            right: 0;
            top: 0;
            bottom: 0;
            width: 360px;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(30px);
            border-left: 1px solid rgba(255,255,255,0.1);
            z-index: 50;
            display: none;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .upnext-panel.visible {
            display: flex;
            transform: translateX(0);
        }

        .upnext-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .upnext-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .upnext-title svg {
            width: 20px;
            height: 20px;
            fill: #22c55e;
        }

        .upnext-close {
            background: none;
            border: none;
            color: #fff;
            opacity: 0.6;
            cursor: pointer;
            padding: 8px;
        }

        .upnext-close:hover {
            opacity: 1;
        }

        .upnext-close svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .upnext-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .upnext-section {
            margin-bottom: 24px;
        }

        .upnext-section-title {
            font-size: 12px;
            font-weight: 600;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .upnext-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 6px;
        }

        .upnext-item:hover {
            background: rgba(255,255,255,0.08);
        }

        .upnext-item-thumb {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .upnext-item-info {
            flex: 1;
            min-width: 0;
        }

        .upnext-item-title {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .upnext-item-artist {
            font-size: 12px;
            opacity: 0.6;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .upnext-item-duration {
            font-size: 11px;
            opacity: 0.5;
            flex-shrink: 0;
        }

        /* Library View Modes */
        .library-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            gap: 12px;
            flex-wrap: wrap;
        }

        .library-view-toggle {
            display: flex;
            gap: 4px;
            background: rgba(0,0,0,0.3);
            padding: 4px;
            border-radius: 8px;
        }

        .view-toggle-btn {
            background: none;
            border: none;
            color: #fff;
            opacity: 0.5;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .view-toggle-btn.active {
            background: rgba(255,255,255,0.1);
            opacity: 1;
        }

        .view-toggle-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .library-sort {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sort-select {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            outline: none;
        }

        .sort-select option {
            background: #1a1a2e;
            color: #fff;
        }

        .library-count {
            font-size: 13px;
            opacity: 0.6;
        }

        /* Grid View for Library */
        .playlist-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 16px;
        }

        .playlist-grid .playlist-item {
            flex-direction: column;
            padding: 12px;
            border-radius: 12px;
            text-align: center;
        }

        .playlist-grid .playlist-item-thumb {
            width: 100%;
            height: auto;
            aspect-ratio: 1;
            margin-bottom: 10px;
            border-radius: 10px;
        }

        .playlist-grid .playlist-item-info {
            width: 100%;
        }

        .playlist-grid .playlist-item-title {
            font-size: 13px;
        }

        .playlist-grid .mini-progress {
            margin-top: 8px;
        }

        /* Radio Button Styles */
        .radio-btn {
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .radio-btn.live::before {
            content: '';
            position: absolute;
            top: -2px;
            right: -2px;
            width: 10px;
            height: 10px;
            background: #ef4444;
            border-radius: 50%;
            animation: pulse-live 1.5s infinite;
        }

        @keyframes pulse-live {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .live-badge {
            background: #ef4444;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            animation: pulse-live 1.5s infinite;
        }

        /* Radio Panel */
        .radio-panel {
            position: fixed;
            top: 70px;
            right: 32px;
            width: 320px;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(30px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.15);
            z-index: 1000;
            display: none;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .radio-panel.visible {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .radio-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .radio-panel-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .radio-panel-close {
            background: none;
            border: none;
            color: #fff;
            opacity: 0.6;
            cursor: pointer;
            padding: 4px;
        }

        .radio-panel-close:hover {
            opacity: 1;
        }

        .radio-status {
            text-align: center;
            padding: 20px 0;
        }

        .radio-status-icon {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 12px;
        }

        .radio-status-icon svg {
            width: 28px;
            height: 28px;
        }

        .radio-status-icon.live {
            background: rgba(239, 68, 68, 0.2);
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            50% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
        }

        .radio-status-text {
            font-size: 14px;
            opacity: 0.7;
            margin-bottom: 4px;
        }

        .radio-listeners {
            font-size: 12px;
            opacity: 0.5;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .radio-listeners svg {
            width: 14px;
            height: 14px;
        }

        .radio-track-info {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 12px;
            margin: 16px 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .radio-track-cover {
            width: 48px;
            height: 48px;
            border-radius: 8px;
            object-fit: cover;
        }

        .radio-track-details {
            flex: 1;
            min-width: 0;
        }

        .radio-track-title {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .radio-track-artist {
            font-size: 12px;
            opacity: 0.6;
        }

        .radio-btn-action {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .radio-btn-action svg {
            width: 18px;
            height: 18px;
        }

        .radio-btn-start {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .radio-btn-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.3);
        }

        .radio-btn-stop {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .radio-btn-stop:hover {
            background: rgba(255,255,255,0.2);
        }

        .radio-btn-join {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .radio-btn-join:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .radio-btn-leave {
            background: rgba(255,255,255,0.1);
            color: white;
            margin-top: 8px;
        }

        .radio-synced-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            margin-top: 12px;
        }

        .radio-synced-badge svg {
            width: 14px;
            height: 14px;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            padding: 0 32px 20px;
            gap: 32px;
            overflow: hidden;
        }

        /* Playlist Sidebar */
        .playlist-sidebar {
            width: 340px;
            min-width: 340px;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 20px;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.08);
            flex-shrink: 0;
        }

        .playlist-sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .playlist-sidebar::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }

        .playlist-sidebar::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }

        .playlist-header {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            opacity: 0.8;
        }

        /* Search Box */
        .search-box {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 10px 14px;
            margin-bottom: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .search-box:focus-within {
            background: rgba(255,255,255,0.12);
            border-color: rgba(255,255,255,0.2);
        }

        .search-box svg {
            width: 18px;
            height: 18px;
            opacity: 0.5;
            flex-shrink: 0;
        }

        .search-box input {
            flex: 1;
            background: none;
            border: none;
            outline: none;
            color: #fff;
            font-size: 14px;
        }

        .search-box input::placeholder {
            color: rgba(255,255,255,0.4);
        }

        #playlist {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .playlist-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease;
            margin-bottom: 6px;
            border: 1px solid transparent;
        }

        .playlist-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .playlist-item:active {
            transform: scale(0.98);
            background: rgba(255,255,255,0.15);
        }

        .playlist-item.hidden {
            display: none;
        }

        .playlist-item.active {
            background: rgba(255,255,255,0.12);
            border-color: rgba(255,255,255,0.15);
        }

        .playlist-item-thumb {
            width: 44px;
            height: 44px;
            border-radius: 8px;
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }

        .playlist-item-info {
            flex: 1;
            min-width: 0;
        }

        .playlist-item-title {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .playlist-item-artist {
            font-size: 12px;
            opacity: 0.6;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Player Section - Main Area */
        .player-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 40px 40px 20px;
            min-width: 0;
            position: relative;
            overflow-y: auto;
        }

        /* Hide ambient background on desktop - only for mobile */
        .player-ambient {
            display: none;
        }

        /* Mobile header hidden on desktop */
        .player-mobile-header {
            display: none;
        }

        /* Album Art */
        .artwork-container {
            position: relative;
            margin-bottom: 24px;
            flex-shrink: 0;
        }

        .artwork {
            width: min(280px, 35vh);
            height: min(280px, 35vh);
            border-radius: 20px;
            object-fit: cover;
            box-shadow: 0 25px 50px rgba(0,0,0,0.4), 0 10px 20px rgba(0,0,0,0.2);
            transition: transform 0.5s ease;
            flex-shrink: 0;
        }

        .artwork:hover {
            transform: scale(1.02);
        }

        /* Track Info */
        .track-info {
            text-align: center;
            margin-bottom: 24px;
            width: 100%;
            max-width: 450px;
        }

        .track-title {
            font-size: 26px;
            font-weight: 700;
            margin-bottom: 6px;
            line-height: 1.2;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-artist {
            font-size: 16px;
            opacity: 0.6;
        }

        /* Progress Bar */
        .progress-section {
            width: 100%;
            max-width: 450px;
            margin-bottom: 24px;
        }

        .progress-bar-container {
            width: 100%;
            height: 5px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            cursor: pointer;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-bar {
            height: 100%;
            background: #fff;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .progress-times {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            opacity: 0.6;
            font-variant-numeric: tabular-nums;
        }

        /* Main Controls */
        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 24px;
        }

        .control-btn {
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.7;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn.active {
            opacity: 1;
            color: #f472b6;
        }

        .control-btn.shuffle-active {
            opacity: 1;
            color: #22c55e;
        }

        .control-btn.shuffle-on {
            opacity: 1;
            color: #fff;
        }

        .control-btn.repeat-on {
            opacity: 1;
            color: #fff;
        }

        .control-btn.repeat-one {
            opacity: 1;
            color: #f87171;
        }

        .control-btn svg {
            width: 26px;
            height: 26px;
            fill: currentColor;
        }

        .play-btn {
            width: 64px;
            height: 64px;
            background: rgba(255,255,255,0.15);
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            flex-shrink: 0;
        }

        .play-btn:hover {
            background: rgba(255,255,255,0.25);
            transform: scale(1.05);
        }

        .play-btn:active {
            transform: scale(0.95);
            background: rgba(255,255,255,0.3);
        }

        .play-btn svg {
            width: 30px;
            height: 30px;
            fill: #fff;
            margin-left: 3px;
        }

        .play-btn.playing svg {
            margin-left: 0;
        }

        /* Secondary Controls Row */
        .secondary-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 450px;
        }

        .secondary-btn {
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 8px;
            opacity: 0.6;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .secondary-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .secondary-btn svg {
            width: 22px;
            height: 22px;
            fill: currentColor;
        }

        .secondary-btn.active {
            color: #f472b6;
            opacity: 1;
        }

        .secondary-btn.timer-active {
            color: #f59e0b;
            opacity: 1;
        }

        /* Sleep Timer Modal */
        .sleep-timer-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            z-index: 200;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sleep-timer-modal.visible {
            display: flex;
            opacity: 1;
        }

        .sleep-timer-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 24px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .sleep-timer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
        }

        .sleep-timer-title {
            font-size: 22px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sleep-timer-title svg {
            width: 28px;
            height: 28px;
            fill: #f59e0b;
        }

        .sleep-timer-close {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .sleep-timer-close:hover {
            background: rgba(255,255,255,0.2);
        }

        .sleep-timer-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .timer-option {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .timer-option:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.2);
        }

        .timer-option.selected {
            background: rgba(245,158,11,0.2);
            border-color: #f59e0b;
        }

        .timer-option-label {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .timer-option-desc {
            font-size: 12px;
            opacity: 0.6;
        }

        .timer-countdown {
            background: rgba(245,158,11,0.1);
            border: 1px solid rgba(245,158,11,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            text-align: center;
        }

        .timer-countdown-time {
            font-size: 32px;
            font-weight: 700;
            color: #f59e0b;
            font-variant-numeric: tabular-nums;
        }

        .timer-countdown-label {
            font-size: 12px;
            opacity: 0.6;
            margin-top: 4px;
        }

        .timer-actions {
            display: flex;
            gap: 12px;
        }

        .timer-btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .timer-btn-start {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: #fff;
        }

        .timer-btn-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(245,158,11,0.4);
        }

        .timer-btn-cancel {
            background: rgba(239,68,68,0.2);
            color: #ef4444;
            border: 1px solid rgba(239,68,68,0.3);
        }

        .timer-btn-cancel:hover {
            background: rgba(239,68,68,0.3);
        }

        .timer-btn-stop {
            background: rgba(239,68,68,0.2);
            color: #ef4444;
            border: 1px solid rgba(239,68,68,0.3);
        }

        .timer-btn-stop:hover {
            background: rgba(239,68,68,0.3);
        }

        /* Volume Control */
        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .volume-control svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
            opacity: 0.6;
        }

        .volume-slider {
            width: 90px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            cursor: pointer;
            outline: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* ========================================
           WAVE ENGINE PANEL
           ======================================== */
        .wave-engine-toggle.active {
            color: #8b5cf6;
            opacity: 1;
        }

        .wave-engine-panel {
            position: fixed;
            top: 0;
            right: -420px;
            width: 400px;
            height: 100%;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            border-left: 1px solid rgba(255,255,255,0.1);
            z-index: 1000;
            transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-y: auto;
            padding: 20px;
            box-shadow: -10px 0 40px rgba(0,0,0,0.5);
        }

        .wave-engine-panel.active {
            right: 0;
        }

        .wave-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .wave-panel-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: 600;
            color: #fff;
        }

        .wave-icon {
            width: 24px;
            height: 24px;
            fill: #8b5cf6;
        }

        .wave-panel-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .wave-toggle {
            position: relative;
            width: 44px;
            height: 24px;
        }

        .wave-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .wave-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255,255,255,0.2);
            transition: 0.3s;
            border-radius: 24px;
        }

        .wave-toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .wave-toggle input:checked + .wave-toggle-slider {
            background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%);
        }

        .wave-toggle input:checked + .wave-toggle-slider:before {
            transform: translateX(20px);
        }

        .wave-panel-close {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            padding: 4px;
        }

        .wave-panel-close svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .wave-section {
            margin-bottom: 24px;
        }

        .wave-section-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.5);
            margin-bottom: 12px;
        }

        .wave-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .wave-preset {
            padding: 8px 16px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            color: rgba(255,255,255,0.7);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .wave-preset:hover {
            background: rgba(255,255,255,0.12);
            color: #fff;
        }

        .wave-preset.active {
            background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%);
            border-color: transparent;
            color: #fff;
        }

        .wave-sliders {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .wave-slider-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .wave-slider-label {
            width: 80px;
            font-size: 13px;
            color: rgba(255,255,255,0.7);
        }

        .wave-slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            cursor: pointer;
            outline: none;
        }

        .wave-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);
        }

        .wave-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .wave-slider-value {
            width: 40px;
            text-align: right;
            font-size: 12px;
            color: rgba(255,255,255,0.5);
        }

        .wave-room-select {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 12px;
        }

        .wave-select {
            flex: 1;
            padding: 10px 14px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            outline: none;
        }

        .wave-select option {
            background: #1a1a2e;
            color: #fff;
        }

        .wave-dynamics-modes {
            display: flex;
            gap: 8px;
        }

        .wave-dynamics-btn {
            flex: 1;
            padding: 10px 12px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: rgba(255,255,255,0.7);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .wave-dynamics-btn:hover {
            background: rgba(255,255,255,0.12);
        }

        .wave-dynamics-btn.active {
            background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%);
            border-color: transparent;
            color: #fff;
        }

        .wave-visualizer {
            width: 100%;
            height: 80px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        /* Crossfade Settings */
        .crossfade-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .crossfade-label {
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .crossfade-switch {
            position: relative;
            width: 48px;
            height: 26px;
            cursor: pointer;
        }

        .crossfade-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .crossfade-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 26px;
            transition: all 0.3s ease;
        }

        .crossfade-slider:before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .crossfade-switch input:checked + .crossfade-slider {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .crossfade-switch input:checked + .crossfade-slider:before {
            transform: translateX(22px);
        }

        .crossfade-duration {
            margin-top: 12px;
            opacity: 0.5;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .crossfade-duration.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Mobile Wave Engine */
        @media (max-width: 768px) {
            .wave-engine-panel {
                width: 100%;
                right: -100%;
                border-radius: 20px 20px 0 0;
                max-height: 85vh;
            }

            .wave-engine-panel.active {
                right: 0;
            }

            .wave-presets {
                gap: 6px;
            }

            .wave-preset {
                padding: 6px 12px;
                font-size: 12px;
            }

            .wave-dynamics-modes {
                flex-wrap: wrap;
            }

            .wave-dynamics-btn {
                flex: 1 1 45%;
            }
        }

        /* ========================================
           SEARCH OVERLAY - Full Screen Search
           ======================================== */
        .search-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 20, 0.98);
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .search-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .search-overlay-container {
            width: 100%;
            max-width: 700px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .search-overlay-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .search-overlay-back {
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .search-overlay-back:hover {
            background: rgba(255,255,255,0.1);
        }

        .search-overlay-input {
            flex: 1;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 25px;
            padding: 14px 20px;
            color: #fff;
            font-size: 16px;
            outline: none;
        }

        .search-overlay-input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .search-results {
            flex: 1;
            overflow-y: auto;
            padding: 20px 0;
        }

        .search-hint {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            opacity: 0.5;
            text-align: center;
        }

        .search-hint p {
            margin-top: 16px;
            font-size: 14px;
        }

        .search-loading,
        .search-empty,
        .search-error {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255,255,255,0.6);
        }

        .search-result-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .search-result-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .search-result-thumb {
            width: 56px;
            height: 56px;
            border-radius: 8px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .search-result-info {
            flex: 1;
            min-width: 0;
        }

        .search-result-title {
            font-size: 15px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
        }

        .search-result-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: rgba(255,255,255,0.6);
        }

        .search-result-channel {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-result-duration {
            flex-shrink: 0;
        }

        .search-result-play {
            background: rgba(255,255,255,0.1);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .search-result-play:hover {
            background: #1db954;
            transform: scale(1.1);
        }

        /* Streaming History Styles */
        .history-item {
            border-left: 3px solid transparent;
            transition: border-color 0.2s, background 0.2s;
        }

        .history-item:hover {
            border-left-color: #1db954;
        }

        .search-result-time {
            font-size: 11px;
            opacity: 0.5;
            flex-shrink: 0;
        }

        .history-clear-btn {
            display: inline-block;
            font-size: 12px;
            color: rgba(255,255,255,0.5);
            cursor: pointer;
            padding: 4px 8px;
            margin-bottom: 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .history-clear-btn:hover {
            color: #ef4444;
            background: rgba(239,68,68,0.1);
        }

        /* ========================================
           SIMILAR SONGS QUEUE - Up Next Panel
           ======================================== */
        .similar-queue {
            position: fixed;
            right: 0;
            top: 0;
            width: 320px;
            height: 100%;
            background: rgba(20, 20, 35, 0.95);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .similar-queue.active {
            transform: translateX(0);
        }

        .similar-queue-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-weight: 600;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .similar-queue-close {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .similar-queue-close:hover {
            color: #fff;
            background: rgba(255,255,255,0.1);
        }

        .similar-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .similar-loading,
        .similar-empty,
        .similar-error {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255,255,255,0.5);
            font-size: 13px;
        }

        .similar-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .similar-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .similar-thumb {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .similar-info {
            flex: 1;
            min-width: 0;
        }

        .similar-title {
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .similar-channel {
            font-size: 11px;
            color: rgba(255,255,255,0.5);
        }

        /* When similar queue is open, shift main content */
        body.queue-open .player-container {
            margin-right: 320px;
            transition: margin-right 0.3s ease;
        }

        /* Mobile styles for similar-queue are now in the main mobile section below */

        /* Mini progress for playlist items */
        .mini-progress {
            width: 100%;
            height: 2px;
            background: rgba(255,255,255,0.1);
            border-radius: 1px;
            margin-top: 6px;
            overflow: hidden;
        }

        .mini-progress-bar {
            height: 100%;
            background: rgba(255,255,255,0.5);
            width: 0%;
            transition: width 0.1s linear;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            opacity: 0.6;
        }

        .empty-state svg {
            width: 48px;
            height: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        /* Responsive - Tablet */
        @media (max-width: 1024px) {
            .main-content {
                padding: 0 20px 20px;
                gap: 20px;
            }

            .playlist-sidebar {
                width: 280px;
                min-width: 280px;
            }

            .artwork {
                width: min(280px, 35vh);
                height: min(280px, 35vh);
            }
        }

        /* =====================================================
           MOBILE UI/UX - Separate Player & Library Views
           Clean, Modern, Touch-Optimized Experience
           ===================================================== */
        
        /* === MINI PLAYER (Mobile Only) === */
        .mini-player {
            display: none;
        }

        /* === LIBRARY TABS (Mobile Only) === */
        .library-tabs {
            display: none;
        }

        /* === MOBILE NAV BAR (Mobile Only) === */
        .mobile-nav {
            display: none;
        }

        @media (max-width: 768px) {
            /* Hide desktop header on mobile */
            .header {
                display: none;
            }

            /* Base Layout */
            .player-container {
                height: 100vh;
                height: 100dvh;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            /* === MAIN CONTENT === */
            .main-content {
                flex-direction: column;
                padding: 0;
                gap: 0;
                overflow: hidden;
                flex: 1;
                position: relative;
            }

            /* === FULL SCREEN PLAYER VIEW === */
            .player-section {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                padding: 20px 24px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                z-index: 200;
                background: #0d1117;
                opacity: 0;
                visibility: hidden;
                transform: translateY(100%);
                transition: all 0.35s cubic-bezier(0.32, 0.72, 0, 1);
                overflow: hidden;
            }

            /* Player Ambient Background */
            .player-ambient {
                display: block;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 0;
                filter: blur(100px) saturate(1.5);
                opacity: 0.4;
                transform: scale(1.5);
                pointer-events: none;
            }

            /* Mobile header visible on mobile */
            .player-mobile-header {
                display: flex;
            }

            .player-ambient img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .player-section > *:not(.player-ambient) {
                position: relative;
                z-index: 1;
            }

            .player-section.active {
                opacity: 1;
                visibility: visible;
                transform: translateY(0);
            }

            /* Hide mini player and floating button when player is active */
            .player-section.active ~ .mini-player,
            body.player-open .mini-player {
                display: none !important;
            }

            body.player-open .floating-shuffle {
                display: none !important;
            }

            /* Player Header */
            .player-mobile-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                width: 100%;
                padding: 0 0 16px;
                flex-shrink: 0;
            }

            .player-collapse-btn {
                background: rgba(255,255,255,0.1);
                border: none;
                color: #fff;
                padding: 10px 16px;
                cursor: pointer;
                border-radius: 25px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
                font-size: 14px;
                font-weight: 500;
            }

            .player-collapse-btn:active {
                background: rgba(255,255,255,0.2);
            }

            .player-collapse-btn svg {
                width: 20px;
                height: 20px;
                fill: currentColor;
            }

            .player-header-title {
                font-size: 12px;
                font-weight: 600;
                opacity: 0.5;
                text-transform: uppercase;
                letter-spacing: 2px;
            }

            .player-header-actions {
                display: flex;
                gap: 4px;
            }

            .player-header-btn {
                background: none;
                border: none;
                color: #fff;
                opacity: 0.7;
                padding: 8px;
                cursor: pointer;
                border-radius: 50%;
            }

            .player-header-btn:active {
                background: rgba(255,255,255,0.1);
            }

            .player-header-btn svg {
                width: 22px;
                height: 22px;
                fill: currentColor;
            }

            .player-header-btn.active {
                color: #ff4757;
                opacity: 1;
            }

            .player-header-btn#waveEngineToggleMobile.active {
                color: #8b5cf6;
            }

            /* Album Artwork - Large & Centered */
            .artwork-container {
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                max-height: 45%;
                margin-bottom: 24px;
            }

            .artwork {
                width: clamp(240px, 70vw, 320px);
                height: clamp(240px, 70vw, 320px);
                border-radius: 16px;
                box-shadow: 
                    0 30px 60px rgba(0,0,0,0.5),
                    0 15px 30px rgba(0,0,0,0.3);
                transition: transform 0.4s ease;
            }

            .artwork:active {
                transform: scale(0.97);
            }

            /* Track Info - Centered */
            .track-info {
                width: 100%;
                text-align: left;
                margin-bottom: 20px;
                padding: 0;
                display: flex;
                align-items: flex-start;
                justify-content: space-between;
                gap: 16px;
            }

            .track-info-text {
                flex: 1;
                min-width: 0;
            }

            .track-title {
                font-size: clamp(20px, 6vw, 26px);
                font-weight: 600;
                letter-spacing: -0.3px;
                line-height: 1.2;
                margin-bottom: 6px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .track-artist {
                font-size: 16px;
                opacity: 0.6;
                font-weight: 400;
            }

            .track-like-btn {
                background: rgba(255,255,255,0.1);
                border: none;
                color: #fff;
                width: 48px;
                height: 48px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                flex-shrink: 0;
            }

            .track-like-btn.active {
                color: #f472b6;
                background: rgba(244,114,182,0.15);
            }

            .track-like-btn svg {
                width: 24px;
                height: 24px;
                fill: currentColor;
            }

            /* Progress Bar */
            .progress-section {
                width: 100%;
                margin-bottom: 24px;
            }

            .progress-bar-container {
                height: 6px;
                border-radius: 3px;
                margin-bottom: 10px;
                background: rgba(255,255,255,0.2);
            }

            .progress-bar {
                background: #fff;
                border-radius: 3px;
            }

            .progress-times {
                font-size: 13px;
                opacity: 0.6;
                font-weight: 500;
            }

            /* Main Controls - Large */
            .controls {
                gap: 20px;
                margin-bottom: 20px;
                padding: 0 16px;
                width: 100%;
                justify-content: center;
                flex-wrap: nowrap;
            }

            .control-btn {
                padding: 10px;
                opacity: 0.7;
                border-radius: 50%;
                flex-shrink: 0;
            }

            .control-btn:active {
                background: rgba(255,255,255,0.1);
                transform: scale(0.9);
            }

            .control-btn svg {
                width: 24px;
                height: 24px;
            }

            .control-btn.active {
                opacity: 1;
                color: #3b82f6;
            }

            /* Play Button - Primary CTA */
            .play-btn {
                width: 64px;
                height: 64px;
                background: #fff;
                border-radius: 50%;
                box-shadow: 0 8px 24px rgba(0,0,0,0.3);
                flex-shrink: 0;
            }

            .play-btn svg {
                width: 28px;
                height: 28px;
                fill: #1a1a2e;
            }

            .play-btn:active {
                transform: scale(0.92);
            }

            /* Secondary Controls - Hide on mobile, move to main controls */
            .secondary-controls {
                display: none;
            }

            .secondary-btn {
                padding: 12px;
                opacity: 0.5;
                border-radius: 50%;
            }

            .secondary-btn:active {
                background: rgba(255,255,255,0.1);
            }

            .secondary-btn svg {
                width: 24px;
                height: 24px;
            }

            /* Hide volume on mobile player */
            .volume-control {
                display: none;
            }

            /* === FULL SCREEN LIBRARY VIEW === */
            .playlist-sidebar {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                min-width: unset;
                border-radius: 0;
                padding: 0;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                background: linear-gradient(180deg, #0a0a14 0%, #0f0f1a 100%);
                border: none;
                z-index: 5;
            }

            .playlist-sidebar::before {
                display: none;
            }

            /* Mobile Library Header */
            .mobile-library-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 16px 20px;
                flex-shrink: 0;
            }

            .mobile-library-logo {
                font-size: 22px;
                font-weight: 700;
                letter-spacing: 2px;
                text-transform: uppercase;
                background: linear-gradient(135deg, #fff 0%, rgba(255,255,255,0.8) 100%);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
            }

            .mobile-library-actions {
                display: flex;
                gap: 8px;
            }

            .mobile-library-btn {
                background: rgba(255,255,255,0.08);
                border: none;
                color: #fff;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            }

            .mobile-library-btn:active {
                background: rgba(255,255,255,0.15);
            }

            .mobile-library-btn svg {
                width: 20px;
                height: 20px;
                fill: currentColor;
            }

            /* Hide library tabs on mobile */
            .library-tabs {
                display: none;
            }

            .library-tab {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 10px 18px;
                background: transparent;
                border: 1px solid rgba(255,255,255,0.15);
                border-radius: 25px;
                color: rgba(255,255,255,0.7);
                font-size: 14px;
                font-weight: 500;
                cursor: pointer;
                white-space: nowrap;
                transition: all 0.2s ease;
                flex-shrink: 0;
            }

            .library-tab.active {
                background: #3b82f6;
                border-color: #3b82f6;
                color: #fff;
            }

            .library-tab svg {
                width: 18px;
                height: 18px;
                fill: currentColor;
            }

            /* Hide old library controls */
            .library-controls {
                display: none;
            }

            .search-box {
                display: none;
            }

            /* Playlist Container */
            #playlist {
                flex: 1;
                overflow-y: auto;
                margin: 0;
                padding: 8px 0 100px;
                -webkit-overflow-scrolling: touch;
            }

            /* Playlist Items - Song Rows */
            .playlist-item {
                display: flex;
                align-items: center;
                padding: 12px 16px;
                margin: 0;
                border-radius: 0;
                background: transparent;
                border: none;
                gap: 14px;
            }

            .playlist-item:active {
                background: rgba(255,255,255,0.05);
            }

            .playlist-item.active {
                background: rgba(59,130,246,0.1);
            }

            .playlist-item.active .playlist-item-title {
                color: #3b82f6;
            }

            .playlist-item-thumb {
                width: 56px;
                height: 56px;
                border-radius: 10px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                flex-shrink: 0;
            }

            .playlist-item-info {
                flex: 1;
                min-width: 0;
            }

            .playlist-item-title {
                font-size: 15px;
                font-weight: 500;
                margin-bottom: 4px;
            }

            .playlist-item-artist {
                font-size: 13px;
                opacity: 0.5;
            }

            .mini-progress {
                display: none;
            }

            /* Song Menu Button */
            .playlist-item-menu {
                background: none;
                border: none;
                color: rgba(255,255,255,0.4);
                padding: 8px;
                cursor: pointer;
                flex-shrink: 0;
            }

            .playlist-item-menu svg {
                width: 20px;
                height: 20px;
                fill: currentColor;
            }

            /* === MINI PLAYER === */
            .mini-player {
                display: flex;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: rgba(20,20,30,0.98);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                border-top: 1px solid rgba(255,255,255,0.08);
                padding: 10px 16px;
                gap: 12px;
                align-items: center;
                z-index: 100;
                cursor: pointer;
            }

            .mini-player-artwork {
                width: 48px;
                height: 48px;
                border-radius: 8px;
                object-fit: cover;
                flex-shrink: 0;
            }

            .mini-player-info {
                flex: 1;
                min-width: 0;
            }

            .mini-player-title {
                font-size: 14px;
                font-weight: 500;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                margin-bottom: 2px;
            }

            .mini-player-artist {
                font-size: 12px;
                opacity: 0.5;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .mini-player-controls {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .mini-player-btn {
                background: none;
                border: none;
                color: #fff;
                padding: 8px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .mini-player-btn svg {
                width: 28px;
                height: 28px;
                fill: currentColor;
            }

            .mini-player-play {
                background: #fff;
                border-radius: 50%;
                width: 44px;
                height: 44px;
            }

            .mini-player-play svg {
                width: 22px;
                height: 22px;
                fill: #1a1a2e;
            }

            .mini-player-progress {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 3px;
                background: rgba(255,255,255,0.1);
            }

            .mini-player-progress-bar {
                height: 100%;
                background: #3b82f6;
                width: 0%;
                transition: width 0.2s linear;
            }

            /* Floating Shuffle Button */
            .floating-shuffle {
                position: fixed;
                bottom: 90px;
                right: 20px;
                width: 56px !important;
                height: 56px !important;
                min-width: 56px;
                max-width: 56px;
                min-height: 56px;
                max-height: 56px;
                background: var(--ambient-color, #3b82f6);
                border-radius: 50%;
                border: none;
                color: #fff;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                box-shadow: 0 6px 20px var(--ambient-shadow, rgba(59,130,246,0.4));
                z-index: 99;
                transition: background 0.5s ease, box-shadow 0.5s ease;
                overflow: hidden;
            }

            .floating-shuffle:active {
                transform: scale(0.92);
            }

            .floating-shuffle svg {
                width: 26px !important;
                height: 26px !important;
                min-width: 26px;
                max-width: 26px;
                min-height: 26px;
                max-height: 26px;
                fill: currentColor;
                flex-shrink: 0;
            }

            /* Hide grid view on mobile for cleaner look */
            .playlist-grid {
                display: flex !important;
                flex-direction: column;
            }

            .playlist-grid .playlist-item {
                flex-direction: row;
                text-align: left;
                padding: 12px 16px;
            }

            .playlist-grid .playlist-item-thumb {
                width: 56px;
                height: 56px;
                margin-bottom: 0;
            }

            /* Hide panels on mobile or adjust */
            .radio-panel {
                top: auto;
                bottom: 0;
                right: 0;
                left: 0;
                width: 100%;
                border-radius: 28px 28px 0 0;
                max-height: 75vh;
                padding: 24px;
            }
        }

        /* === SMALL SCREENS === */
        @media (max-width: 380px) {
            .controls {
                gap: 12px;
                padding: 0 8px;
            }

            .control-btn svg {
                width: 22px;
                height: 22px;
            }

            .play-btn {
                width: 56px;
                height: 56px;
            }

            .play-btn svg {
                width: 24px;
                height: 24px;
            }

            .artwork {
                width: clamp(200px, 60vw, 260px);
                height: clamp(200px, 60vw, 260px);
            }
        }

        /* Continue mobile styles */
        @media (max-width: 768px) {
            .upnext-panel {
                width: 100%;
                height: 65%;
                top: auto;
                bottom: 0;
                border-left: none;
                border-radius: 28px 28px 0 0;
            }

            .similar-queue {
                width: 100%;
                height: 55%;
                top: auto;
                bottom: 0;
                transform: translateY(100%);
                border-left: none;
                border-radius: 28px 28px 0 0;
            }

            .similar-queue.active {
                transform: translateY(0);
            }

            body.queue-open .player-container {
                margin-right: 0;
            }

            /* Search page adjustments */
            .search-page {
                z-index: 200;
            }
        }

        /* === LANDSCAPE MODE === */
        @media (max-width: 768px) and (orientation: landscape) {
            .player-section.active {
                flex-direction: row;
                padding: 16px 24px;
            }

            .artwork-container {
                flex: 0 0 40%;
                max-height: 100%;
                margin-bottom: 0;
                margin-right: 24px;
            }

            .artwork {
                width: clamp(120px, 30vh, 180px);
                height: clamp(120px, 30vh, 180px);
            }

            .player-section > *:not(.artwork-container):not(.player-mobile-header) {
                flex: 1;
            }

            .controls {
                gap: 24px;
            }

            .play-btn {
                width: 60px;
                height: 60px;
            }
        }
    </style>
</head>
<body>
    <!-- Ambient Background -->
    <div class="ambient-bg" id="ambientBg">
        <img id="ambientImg" src="{{ url_for('static', filename='default-artwork.png') }}" alt="">
    </div>

    <!-- Search Overlay -->
    <div class="search-overlay" id="searchOverlay">
        <div class="search-overlay-container">
            <div class="search-overlay-header">
                <button class="search-overlay-back" id="closeSearchBtn">
                    <svg viewBox="0 0 24 24" width="24" height="24">
                        <path fill="currentColor" d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                    </svg>
                </button>
                <input type="text" class="search-overlay-input" id="searchOverlayInput" placeholder="Search songs, artists...">
            </div>
            <div class="search-results" id="searchResults">
                <div class="search-hint">
                    <svg viewBox="0 0 24 24" width="48" height="48">
                        <path fill="currentColor" d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                    </svg>
                    <p>Search for your favorite songs</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Similar Songs Queue (for streaming mode) -->
    <div class="similar-queue" id="similarQueue">
        <div class="similar-queue-header">
            <span>Up Next</span>
            <button class="similar-queue-close" id="closeSimilarQueue">
                <svg viewBox="0 0 24 24" width="16" height="16">
                    <path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                </svg>
            </button>
        </div>
        <div class="similar-list" id="similarList"></div>
    </div>

    <div class="player-container">
        <!-- Header -->
        <header class="header">
            <div class="header-title">Musify</div>
            <nav class="header-nav">
                <!-- Tab Navigation -->
                <div class="tab-nav">
                    <button class="tab-btn active" id="libraryTab" onclick="showLibrary()">
                        <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
                        Library
                    </button>
                    <button class="tab-btn" id="searchTab" onclick="showSearchPage()">
                        <svg viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
                        Search
                    </button>
                </div>

                <!-- Stream Toggle -->
                <div class="stream-toggle">
                    <span class="stream-toggle-label">Stream</span>
                    <label class="stream-toggle-switch">
                        <input type="checkbox" id="streamModeToggle">
                        <span class="stream-toggle-slider"></span>
                    </label>
                    <span class="stream-indicator" id="streamIndicator">LIVE</span>
                </div>

                <a href="/">Download</a>
                <button id="installBtn" class="install-btn" title="Install Musify App" style="display:none;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                    </svg>
                    Install
                </button>
                <button id="radioBtn" class="radio-btn" title="Live Radio">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3.24 6.15C2.51 6.43 2 7.17 2 8v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2H8.3l8.26-3.34L15.88 1 3.24 6.15M7 20a2 2 0 0 1-2-2 2 2 0 0 1 2-2 2 2 0 0 1 2 2 2 2 0 0 1-2 2m13-8h-2v-2h-2v2H4v2h12v2h2v-2h2v-2Z"/>
                    </svg>
                    <span id="radioLiveBadge" class="live-badge" style="display:none;">LIVE</span>
                </button>
                <button id="upnextBtn" onclick="toggleUpNext()" title="Up Next" style="display:none;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h10v2H4z"/>
                    </svg>
                </button>
                <button id="themeToggle">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/>
                    </svg>
                </button>
            </nav>
        </header>

        <!-- Search Page -->
        <div id="searchPage" class="search-page">
            <div class="search-header">
                <button class="search-back-btn" onclick="hideSearchPage()">
                    <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
                </button>
                <div class="search-input-container">
                    <svg class="search-input-icon" viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
                    <input type="text" id="streamSearchInput" class="search-input-large" placeholder="Search songs, artists, albums...">
                </div>
            </div>
            <div class="search-content" id="searchContent">
                <div class="search-section-title">Start typing to search...</div>
                <div id="searchResultsContainer"></div>
            </div>
        </div>

        <!-- Up Next Panel -->
        <div id="upnextPanel" class="upnext-panel">
            <div class="upnext-header">
                <div class="upnext-title">
                    <svg viewBox="0 0 24 24"><path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h10v2H4z"/></svg>
                    Up Next
                </div>
                <button class="upnext-close" onclick="toggleUpNext()">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
                </button>
            </div>
            <div class="upnext-content">
                <div class="upnext-section">
                    <div class="upnext-section-title">Now Playing</div>
                    <div id="upnextNowPlaying"></div>
                </div>
                <div class="upnext-section">
                    <div class="upnext-section-title">Similar Songs</div>
                    <div id="upnextSimilar">
                        <div style="text-align:center;padding:20px;opacity:0.5;font-size:13px;">
                            Enable streaming mode to see suggestions
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Radio Panel -->
        <div id="radioPanel" class="radio-panel">
            <div class="radio-panel-header">
                <div class="radio-panel-title">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3.24 6.15C2.51 6.43 2 7.17 2 8v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2H8.3l8.26-3.34L15.88 1 3.24 6.15M7 20a2 2 0 0 1-2-2 2 2 0 0 1 2-2 2 2 0 0 1 2 2 2 2 0 0 1-2 2m13-8h-2v-2h-2v2H4v2h12v2h2v-2h2v-2Z"/>
                    </svg>
                    Live Radio
                </div>
                <button class="radio-panel-close" id="radioPanelClose">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                    </svg>
                </button>
            </div>
            
            <!-- Host View (only visible on localhost) -->
            <div id="hostView" style="display:none;">
                <div class="radio-status">
                    <div class="radio-status-icon" id="hostStatusIcon">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3.24 6.15C2.51 6.43 2 7.17 2 8v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2H8.3l8.26-3.34L15.88 1 3.24 6.15M7 20a2 2 0 0 1-2-2 2 2 0 0 1 2-2 2 2 0 0 1 2 2 2 2 0 0 1-2 2m13-8h-2v-2h-2v2H4v2h12v2h2v-2h2v-2Z"/>
                        </svg>
                    </div>
                    <div class="radio-status-text" id="hostStatusText">Radio is offline</div>
                    <div class="radio-listeners" id="hostListeners" style="display:none;">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
                        </svg>
                        <span id="hostListenerCount">0</span> listeners
                    </div>
                </div>
                
                <div id="hostTrackInfo" class="radio-track-info" style="display:none;">
                    <img id="hostTrackCover" class="radio-track-cover" src="/static/default-artwork.png" alt="">
                    <div class="radio-track-details">
                        <div class="radio-track-title" id="hostTrackTitle">No track playing</div>
                        <div class="radio-track-artist" id="hostTrackArtist">-</div>
                    </div>
                </div>
                
                <button id="startRadioBtn" class="radio-btn-action radio-btn-start">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    Start Broadcasting
                </button>
                <button id="stopRadioBtn" class="radio-btn-action radio-btn-stop" style="display:none;">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M6 6h12v12H6z"/>
                    </svg>
                    Stop Broadcasting
                </button>
            </div>
            
            <!-- Participant View -->
            <div id="participantView" style="display:none;">
                <div class="radio-status">
                    <div class="radio-status-icon" id="participantStatusIcon">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3.24 6.15C2.51 6.43 2 7.17 2 8v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2H8.3l8.26-3.34L15.88 1 3.24 6.15M7 20a2 2 0 0 1-2-2 2 2 0 0 1 2-2 2 2 0 0 1 2 2 2 2 0 0 1-2 2m13-8h-2v-2h-2v2H4v2h12v2h2v-2h2v-2Z"/>
                        </svg>
                    </div>
                    <div class="radio-status-text" id="participantStatusText">Radio is offline</div>
                    <div class="radio-listeners" id="participantListeners" style="display:none;">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
                        </svg>
                        <span id="participantListenerCount">0</span> listeners
                    </div>
                </div>
                
                <div id="participantTrackInfo" class="radio-track-info" style="display:none;">
                    <img id="participantTrackCover" class="radio-track-cover" src="/static/default-artwork.png" alt="">
                    <div class="radio-track-details">
                        <div class="radio-track-title" id="participantTrackTitle">No track playing</div>
                        <div class="radio-track-artist" id="participantTrackArtist">-</div>
                    </div>
                </div>
                
                <button id="joinRadioBtn" class="radio-btn-action radio-btn-join" style="display:none;">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                    Join Radio
                </button>
                <button id="leaveRadioBtn" class="radio-btn-action radio-btn-leave" style="display:none;">
                    Leave Radio
                </button>
                
                <div id="syncedBadge" class="radio-synced-badge" style="display:none;">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                    Synced with host
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Playlist Sidebar -->
            <aside class="playlist-sidebar">
                <!-- Mobile Library Header -->
                <div class="mobile-library-header">
                    <span class="mobile-library-logo">Musify</span>
                    <div class="mobile-library-actions">
                        <button class="mobile-library-btn" id="searchLibraryBtn">
                            <svg viewBox="0 0 24 24"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg>
                        </button>
                    </div>
                </div>

                <div class="library-controls">
                    <h2 class="playlist-header">{% if on_host %}Trending{% else %}Library{% endif %}</h2>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <span class="library-count" id="libraryCount">{% if on_host %}{{ trending_songs|length }} trending{% else %}{{ songs|length }} songs{% endif %}</span>
                        {% if not on_host %}
                        <div class="library-view-toggle">
                            <button class="view-toggle-btn active" id="listViewBtn" onclick="setLibraryView('list')" title="List view">
                                <svg viewBox="0 0 24 24"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/></svg>
                            </button>
                            <button class="view-toggle-btn" id="gridViewBtn" onclick="setLibraryView('grid')" title="Grid view">
                                <svg viewBox="0 0 24 24"><path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"/></svg>
                            </button>
                        </div>
                        <select class="sort-select" id="sortSelect" onchange="sortLibrary(this.value)">
                            <option value="name">A-Z</option>
                            <option value="name-desc">Z-A</option>
                            <option value="recent">Recent</option>
                        </select>
                        {% endif %}
                    </div>
                </div>
                <!-- Search Box -->
                <div class="search-box">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                    </svg>
                    <input type="text" id="searchInput" placeholder="{% if on_host %}Search trending...{% else %}Filter library...{% endif %}">
                </div>
                
                <ul id="playlist">
                    {% if on_host and trending_songs %}
                    <!-- Trending Songs (ON_HOST mode) -->
                    {% for song in trending_songs %}
                    <li class="playlist-item trending-item" data-index="{{ loop.index0 }}" data-video-id="{{ song.id }}" data-title="{{ song.title }}" data-artist="{{ song.artist }}" data-thumbnail="{{ song.thumbnail }}" data-duration="{{ song.duration_secs }}">
                        <img class="playlist-item-thumb" src="{{ song.thumbnail }}" alt="Cover" onerror="this.src='{{ url_for('static', filename='default-artwork.png') }}'">
                        <div class="playlist-item-info">
                            <div class="playlist-item-title">{{ song.title }}</div>
                            <div class="playlist-item-artist">{{ song.artist }}</div>
                            <div style="display: flex; align-items: center; gap: 8px; margin-top: 4px;">
                                <span style="font-size: 11px; opacity: 0.5;">{{ song.duration }}</span>
                                <span style="background: linear-gradient(135deg, #ef4444, #dc2626); padding: 2px 6px; border-radius: 4px; font-size: 9px; font-weight: 600;">TRENDING</span>
                            </div>
                            <div class="mini-progress">
                                <div class="mini-progress-bar"></div>
                            </div>
                        </div>
                        <button class="playlist-item-menu" onclick="event.stopPropagation();">
                            <svg viewBox="0 0 24 24"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
                        </button>
                    </li>
                    {% else %}
                    <li class="empty-state">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                        </svg>
                        <p>Loading trending songs...</p>
                        <p style="font-size: 14px; margin-top: 8px;">Please wait while we fetch the latest hits</p>
                    </li>
                    {% endfor %}
                    {% endif %}
                    
                    <!-- Local Library Songs (always shown) -->
                    {% for song in songs %}
                    <li class="playlist-item" data-index="{{ loop.index0 }}" data-src="{{ url_for('play', filename=song) }}" data-title="{{ song[:-4] if song.endswith('.mp3') else song }}" data-file="{{ song }}">
                        <img class="playlist-item-thumb" src="{{ url_for('cover', filename=song) }}" alt="Cover" onerror="this.src='{{ url_for('static', filename='default-artwork.png') }}'">
                        <div class="playlist-item-info">
                            <div class="playlist-item-title">{{ song[:-4] if song.endswith('.mp3') else song }}</div>
                            <div class="playlist-item-artist"><unknown></div>
                            <div class="mini-progress">
                                <div class="mini-progress-bar"></div>
                            </div>
                        </div>
                        <button class="playlist-item-menu" onclick="event.stopPropagation();">
                            <svg viewBox="0 0 24 24"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
                        </button>
                    </li>
                    {% endfor %}
                    
                    <!-- Empty state: only show when both local songs and trending songs are empty -->
                    {% if not songs and (not on_host or not trending_songs) %}
                    <li class="empty-state">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                        </svg>
                        <p>No songs found</p>
                        <p style="font-size: 14px; margin-top: 8px;">Download some music to get started</p>
                    </li>
                    {% endif %}
                </ul>
            </aside>

            <!-- Player Section -->
            <section class="player-section" id="playerSection">
                <!-- Mobile Player Header -->
                <!-- Ambient Background -->
                <div class="player-ambient" id="playerAmbient">
                    <img class="ambient-image" id="ambientImage" src="{{ url_for('static', filename='default-artwork.png') }}" alt="">
                </div>

                <div class="player-mobile-header">
                    <button class="player-collapse-btn" id="collapsePlayerBtn" onclick="collapsePlayer()">
                        <svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                    </button>
                    <span class="player-header-title">NOW PLAYING</span>
                    <div class="player-header-actions">
                        <button class="player-header-btn" id="waveEngineToggleMobile" title="Wave Engine">
                            <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
                        </button>
                        <button class="player-header-btn" id="trackLikeBtnHeader">
                            <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                        </button>
                    </div>
                </div>

                <!-- Artwork -->
                <div class="artwork-container">
                    <img id="artwork" class="artwork" src="{{ url_for('static', filename='default-artwork.png') }}" alt="Album Art">
                </div>

                <!-- Track Info with Like Button -->
                <div class="track-info">
                    <div class="track-info-text">
                        <h1 id="track-title" class="track-title">Select a track</h1>
                        <p id="track-artist" class="track-artist"><unknown></p>
                    </div>
                    <button class="track-like-btn" id="trackLikeBtn">
                        <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                    </button>
                </div>

                <!-- Progress -->
                <div class="progress-section">
                    <div id="progress-bar-container" class="progress-bar-container">
                        <div id="progress-bar" class="progress-bar"></div>
                    </div>
                    <div class="progress-times">
                        <span id="currentTime">00:00</span>
                        <span id="duration">00:00</span>
                    </div>
                </div>

                <!-- Main Controls -->
                <div class="controls">
                    <button class="control-btn" id="shuffleBtn" title="Shuffle">
                        <svg viewBox="0 0 24 24">
                            <path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/>
                        </svg>
                    </button>
                    <button class="control-btn" id="prevBtn" title="Previous">
                        <svg viewBox="0 0 24 24">
                            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                        </svg>
                    </button>
                    <button class="play-btn" id="playBtn" title="Play">
                        <svg id="playIconSvg" viewBox="0 0 24 24">
                            <path id="playIconPath" d="M8 5v14l11-7z"/>
                        </svg>
                    </button>
                    <button class="control-btn" id="nextBtn" title="Next">
                        <svg viewBox="0 0 24 24">
                            <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                        </svg>
                    </button>
                    <button class="control-btn" id="repeatBtn" title="Repeat">
                        <svg viewBox="0 0 24 24">
                            <path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>
                        </svg>
                    </button>
                </div>

                <!-- Secondary Controls -->
                <div class="secondary-controls">
                    <button class="secondary-btn" id="likeBtn" title="Like">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                        </svg>
                    </button>
                    <button class="secondary-btn" id="sleepTimerBtn" title="Sleep Timer">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm4.2 14.2L11 13V7h1.5v5.2l4.5 2.7-.8 1.3z"/>
                        </svg>
                    </button>
                    <button class="secondary-btn wave-engine-toggle" id="waveEngineToggle" title="Wave Engine">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                        </svg>
                    </button>
                    <button class="secondary-btn" id="menuBtn" title="More">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>
                        </svg>
                    </button>
                    <div class="volume-control">
                        <svg viewBox="0 0 24 24">
                            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                        </svg>
                        <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="80">
                    </div>
                </div>
            </section>

            <!-- Wave Engine Panel -->
            <div class="wave-engine-panel" id="waveEnginePanel">
                <div class="wave-panel-header">
                    <div class="wave-panel-title">
                        <svg viewBox="0 0 24 24" class="wave-icon">
                            <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                        </svg>
                        <span>Wave Engine</span>
                    </div>
                    <div class="wave-panel-controls">
                        <label class="wave-toggle">
                            <input type="checkbox" id="waveEngineEnabled" checked>
                            <span class="wave-toggle-slider"></span>
                        </label>
                        <button class="wave-panel-close" id="waveEngineClose">
                            <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
                        </button>
                    </div>
                </div>

                <!-- Presets -->
                <div class="wave-section">
                    <div class="wave-section-title">Sound Profile</div>
                    <div class="wave-presets" id="wavePresets">
                        <button class="wave-preset active" data-preset="balanced">Balanced</button>
                        <button class="wave-preset" data-preset="studio">Studio</button>
                        <button class="wave-preset" data-preset="analog">Analog</button>
                        <button class="wave-preset" data-preset="concert">Concert</button>
                        <button class="wave-preset" data-preset="club">Club</button>
                        <button class="wave-preset" data-preset="basshead">Bass</button>
                        <button class="wave-preset" data-preset="vocal">Vocal</button>
                        <button class="wave-preset" data-preset="audiophile">Audiophile</button>
                        <button class="wave-preset" data-preset="night">Night</button>
                    </div>
                </div>

                <!-- Acoustic Color -->
                <div class="wave-section">
                    <div class="wave-section-title">Acoustic Color</div>
                    <div class="wave-sliders">
                        <div class="wave-slider-row">
                            <span class="wave-slider-label">Warmth</span>
                            <input type="range" class="wave-slider" id="waveWarmth" min="0" max="100" value="50">
                            <span class="wave-slider-value" id="waveWarmthVal">50%</span>
                        </div>
                        <div class="wave-slider-row">
                            <span class="wave-slider-label">Brightness</span>
                            <input type="range" class="wave-slider" id="waveBrightness" min="0" max="100" value="50">
                            <span class="wave-slider-value" id="waveBrightnessVal">50%</span>
                        </div>
                        <div class="wave-slider-row">
                            <span class="wave-slider-label">Body</span>
                            <input type="range" class="wave-slider" id="waveBody" min="0" max="100" value="50">
                            <span class="wave-slider-value" id="waveBodyVal">50%</span>
                        </div>
                        <div class="wave-slider-row">
                            <span class="wave-slider-label">Air</span>
                            <input type="range" class="wave-slider" id="waveAir" min="0" max="100" value="50">
                            <span class="wave-slider-value" id="waveAirVal">50%</span>
                        </div>
                        <div class="wave-slider-row">
                            <span class="wave-slider-label">Punch</span>
                            <input type="range" class="wave-slider" id="wavePunch" min="0" max="100" value="50">
                            <span class="wave-slider-value" id="wavePunchVal">50%</span>
                        </div>
                    </div>
                </div>

                <!-- Spatial -->
                <div class="wave-section">
                    <div class="wave-section-title">Spatial Audio</div>
                    <div class="wave-sliders">
                        <div class="wave-slider-row">
                            <span class="wave-slider-label">Width</span>
                            <input type="range" class="wave-slider" id="waveSpatialWidth" min="0" max="150" value="100">
                            <span class="wave-slider-value" id="waveSpatialWidthVal">100%</span>
                        </div>
                        <div class="wave-slider-row">
                            <span class="wave-slider-label">Depth</span>
                            <input type="range" class="wave-slider" id="waveSpatialDepth" min="0" max="100" value="50">
                            <span class="wave-slider-value" id="waveSpatialDepthVal">50%</span>
                        </div>
                    </div>
                    <div class="wave-room-select">
                        <span class="wave-slider-label">Room</span>
                        <select id="waveRoom" class="wave-select">
                            <option value="studio">Studio</option>
                            <option value="analog">Analog Warmth</option>
                            <option value="concert">Concert Hall</option>
                            <option value="club">Club</option>
                            <option value="theater">Theater</option>
                            <option value="open">Open Air</option>
                        </select>
                    </div>
                </div>

                <!-- Dynamics -->
                <div class="wave-section">
                    <div class="wave-section-title">Dynamics</div>
                    <div class="wave-dynamics-modes" id="waveDynamicsModes">
                        <button class="wave-dynamics-btn" data-mode="pure">Pure</button>
                        <button class="wave-dynamics-btn active" data-mode="balanced">Balanced</button>
                        <button class="wave-dynamics-btn" data-mode="enhanced">Enhanced</button>
                        <button class="wave-dynamics-btn" data-mode="night">Night</button>
                    </div>
                </div>

                <!-- Crossfade -->
                <div class="wave-section">
                    <div class="wave-section-title">Crossfade</div>
                    <div class="crossfade-toggle">
                        <div class="crossfade-label">
                            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor">
                                <path d="M7 17.5l4.5-4.5L16 17.5V7.5l-4.5 4.5L7 7.5z"/>
                            </svg>
                            Enable Crossfade
                        </div>
                        <label class="crossfade-switch">
                            <input type="checkbox" id="crossfadeToggle">
                            <span class="crossfade-slider"></span>
                        </label>
                    </div>
                    <div class="crossfade-duration" id="crossfadeDurationSection">
                        <div class="wave-control-label">Crossfade Duration</div>
                        <div class="wave-slider-group">
                            <input type="range" class="wave-slider" id="crossfadeDuration" min="2" max="12" value="6" step="1">
                            <span class="wave-slider-value" id="crossfadeDurationValue">6s</span>
                        </div>
                    </div>
                </div>

                <!-- Visualizer -->
                <div class="wave-section">
                    <div class="wave-section-title">Visualizer</div>
                    <canvas id="waveVisualizer" class="wave-visualizer"></canvas>
                </div>
            </div>
        </main>

        <!-- Sleep Timer Modal -->
        <div class="sleep-timer-modal" id="sleepTimerModal">
            <div class="sleep-timer-content">
                <div class="sleep-timer-header">
                    <div class="sleep-timer-title">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm4.2 14.2L11 13V7h1.5v5.2l4.5 2.7-.8 1.3z"/>
                        </svg>
                        Sleep Timer
                    </div>
                    <button class="sleep-timer-close" onclick="closeSleepTimer()">
                        <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                        </svg>
                    </button>
                </div>
                
                <div id="timerSetup">
                    <div class="sleep-timer-options">
                        <div class="timer-option" data-minutes="15">
                            <div class="timer-option-label">15 min</div>
                            <div class="timer-option-desc">Quick nap</div>
                        </div>
                        <div class="timer-option" data-minutes="30">
                            <div class="timer-option-label">30 min</div>
                            <div class="timer-option-desc">Short rest</div>
                        </div>
                        <div class="timer-option" data-minutes="45">
                            <div class="timer-option-label">45 min</div>
                            <div class="timer-option-desc">Meditation</div>
                        </div>
                        <div class="timer-option" data-minutes="60">
                            <div class="timer-option-label">60 min</div>
                            <div class="timer-option-desc">Deep sleep</div>
                        </div>
                        <div class="timer-option" data-minutes="90">
                            <div class="timer-option-label">90 min</div>
                            <div class="timer-option-desc">Full cycle</div>
                        </div>
                        <div class="timer-option" data-minutes="-1">
                            <div class="timer-option-label">End track</div>
                            <div class="timer-option-desc">Current song</div>
                        </div>
                    </div>
                    <div class="timer-actions">
                        <button class="timer-btn timer-btn-start" onclick="startSleepTimer()">Start Timer</button>
                    </div>
                </div>

                <div id="timerActive" style="display: none;">
                    <div class="timer-countdown">
                        <div class="timer-countdown-time" id="timerDisplay">00:00</div>
                        <div class="timer-countdown-label">Time remaining</div>
                    </div>
                    <div class="timer-actions">
                        <button class="timer-btn timer-btn-stop" onclick="stopSleepTimer()">Stop Timer</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mini Player (Mobile) -->
        <div class="mini-player" id="miniPlayer" onclick="expandPlayer()">
            <img class="mini-player-artwork" id="miniPlayerArtwork" src="{{ url_for('static', filename='default-artwork.png') }}" alt="">
            <div class="mini-player-info">
                <div class="mini-player-title" id="miniPlayerTitle">Select a track</div>
                <div class="mini-player-artist" id="miniPlayerArtist"><unknown></div>
            </div>
            <div class="mini-player-controls">
                <button class="mini-player-btn mini-player-play" id="miniPlayerPlayBtn" onclick="event.stopPropagation(); togglePlay();">
                    <svg viewBox="0 0 24 24" id="miniPlayIcon">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                </button>
                <button class="mini-player-btn" onclick="event.stopPropagation(); playNext();">
                    <svg viewBox="0 0 24 24">
                        <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                    </svg>
                </button>
            </div>
            <div class="mini-player-progress">
                <div class="mini-player-progress-bar" id="miniPlayerProgress"></div>
            </div>
        </div>

        <!-- Floating Shuffle Button (Mobile) -->
        <button class="floating-shuffle" id="floatingShuffleBtn" onclick="shuffleAndPlay()">
            <svg width="26" height="26" viewBox="0 0 24 24" fill="currentColor">
                <path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/>
            </svg>
        </button>
    </div>

    <!-- PWA Install Banner -->
    <div id="pwaInstallBanner" class="pwa-install-banner">
        <div class="pwa-install-icon">
            <svg viewBox="0 0 24 24">
                <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
            </svg>
        </div>
        <div class="pwa-install-content">
            <div class="pwa-install-title">Install Musify</div>
            <div class="pwa-install-desc">Add to your home screen for quick access</div>
        </div>
        <div class="pwa-install-actions">
            <button class="pwa-install-btn primary" onclick="installPWA()">Install</button>
            <button class="pwa-install-btn secondary" onclick="dismissInstallBanner()">Later</button>
        </div>
    </div>

    <audio id="audio" preload="metadata"></audio>
    <audio id="streamingAudio" preload="metadata"></audio>

    <!-- Wave Engine -->
    <script src="{{ url_for('static', filename='wave-engine.js') }}"></script>

    <script>
        // Musify Player with Ambient Mode
        
        // App Configuration (from server)
        const APP_CONFIG = {
            onHost: {{ 'true' if on_host else 'false' }}
        };
        
        document.addEventListener('DOMContentLoaded', () => {
            const playlist = document.getElementById('playlist');
            const audio = document.getElementById('audio');
            const streamingAudio = document.getElementById('streamingAudio');
            const playBtn = document.getElementById('playBtn');
            const playIcon = document.getElementById('playIcon');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const artwork = document.getElementById('artwork');
            const ambientImg = document.getElementById('ambientImg');
            const trackTitle = document.getElementById('track-title');
            const trackArtist = document.getElementById('track-artist');
            const progressBar = document.getElementById('progress-bar');
            const progressContainer = document.getElementById('progress-bar-container');
            const currentTimeEl = document.getElementById('currentTime');
            const durationEl = document.getElementById('duration');
            const volumeSlider = document.getElementById('volumeSlider');
            const likeBtn = document.getElementById('likeBtn');
            const shuffleBtn = document.getElementById('shuffleBtn');
            const repeatBtn = document.getElementById('repeatBtn');
            const searchInput = document.getElementById('searchInput');
            const playIconPath = document.getElementById('playIconPath');
            
            // Mobile elements
            const playerSection = document.getElementById('playerSection');
            const miniPlayer = document.getElementById('miniPlayer');
            const miniPlayerArtwork = document.getElementById('miniPlayerArtwork');
            const miniPlayerTitle = document.getElementById('miniPlayerTitle');
            const miniPlayerArtist = document.getElementById('miniPlayerArtist');
            const miniPlayerProgress = document.getElementById('miniPlayerProgress');
            const miniPlayIcon = document.getElementById('miniPlayIcon');
            const floatingShuffleBtn = document.getElementById('floatingShuffleBtn');
            
            // Current active audio element (switches between library and streaming)
            let activeAudio = audio;

            let tracks = Array.from(playlist.querySelectorAll('.playlist-item[data-src]'));
            let currentIndex = -1;
            let isPlaying = false;
            let isShuffled = false;
            let repeatMode = 0; // 0: off, 1: all, 2: one
            let isMobile = window.innerWidth <= 768;
            
            // Sleep Timer
            let sleepTimerActive = false;
            let sleepTimerMinutes = 0;
            let sleepTimerEndTime = null;
            let sleepTimerInterval = null;
            let sleepTimerEndTrack = false;
            
            // Crossfade
            let crossfadeEnabled = false;
            let crossfadeDuration = 6; // seconds
            let crossfading = false;
            let nextTrackAudio = null;
            
            // ========================================
            // SLEEP TIMER FUNCTIONS
            // ========================================
            window.openSleepTimer = function() {
                const modal = document.getElementById('sleepTimerModal');
                modal.classList.add('visible');
                
                // Update UI based on current timer state
                if (sleepTimerActive) {
                    document.getElementById('timerSetup').style.display = 'none';
                    document.getElementById('timerActive').style.display = 'block';
                } else {
                    document.getElementById('timerSetup').style.display = 'block';
                    document.getElementById('timerActive').style.display = 'none';
                }
            };
            
            window.closeSleepTimer = function() {
                const modal = document.getElementById('sleepTimerModal');
                modal.classList.remove('visible');
            };
            
            window.startSleepTimer = function() {
                const selectedOption = document.querySelector('.timer-option.selected');
                if (!selectedOption) return;
                
                const minutes = parseInt(selectedOption.dataset.minutes);
                
                if (minutes === -1) {
                    // End of current track mode
                    sleepTimerEndTrack = true;
                    sleepTimerActive = true;
                    sleepTimerMinutes = -1;
                    document.getElementById('sleepTimerBtn').classList.add('timer-active');
                    closeSleepTimer();
                    console.log('Sleep timer set to end after current track');
                } else {
                    // Time-based timer
                    sleepTimerMinutes = minutes;
                    sleepTimerEndTime = Date.now() + (minutes * 60 * 1000);
                    sleepTimerActive = true;
                    sleepTimerEndTrack = false;
                    
                    // Update UI
                    document.getElementById('timerSetup').style.display = 'none';
                    document.getElementById('timerActive').style.display = 'block';
                    document.getElementById('sleepTimerBtn').classList.add('timer-active');
                    
                    // Start countdown
                    updateTimerDisplay();
                    sleepTimerInterval = setInterval(updateTimerDisplay, 1000);
                    
                    console.log(`Sleep timer set for ${minutes} minutes`);
                }
            };
            
            window.stopSleepTimer = function() {
                sleepTimerActive = false;
                sleepTimerEndTrack = false;
                if (sleepTimerInterval) {
                    clearInterval(sleepTimerInterval);
                    sleepTimerInterval = null;
                }
                document.getElementById('sleepTimerBtn').classList.remove('timer-active');
                closeSleepTimer();
                console.log('Sleep timer stopped');
            };
            
            function updateTimerDisplay() {
                if (!sleepTimerActive || sleepTimerEndTrack) return;
                
                const remaining = sleepTimerEndTime - Date.now();
                
                if (remaining <= 0) {
                    // Timer finished
                    fadeOutAndStop();
                    return;
                }
                
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                document.getElementById('timerDisplay').textContent = 
                    `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
            
            function fadeOutAndStop() {
                const currentAudio = isStreamingPlayback ? streamingAudio : audio;
                const originalVolume = currentAudio.volume;
                const fadeSteps = 30;
                const fadeInterval = 2000 / fadeSteps; // 2 second fade
                let step = 0;
                
                const fadeIntervalId = setInterval(() => {
                    step++;
                    currentAudio.volume = originalVolume * (1 - step / fadeSteps);
                    
                    if (step >= fadeSteps) {
                        clearInterval(fadeIntervalId);
                        pause();
                        currentAudio.volume = originalVolume;
                        stopSleepTimer();
                        console.log('Sleep timer: Music stopped with fade-out');
                    }
                }, fadeInterval);
            }
            
            // Timer option selection
            document.addEventListener('click', (e) => {
                const option = e.target.closest('.timer-option');
                if (option) {
                    document.querySelectorAll('.timer-option').forEach(o => o.classList.remove('selected'));
                    option.classList.add('selected');
                }
            });
            
            // Sleep timer button click
            document.getElementById('sleepTimerBtn')?.addEventListener('click', openSleepTimer);
            
            // Close modal on outside click
            document.getElementById('sleepTimerModal')?.addEventListener('click', (e) => {
                if (e.target.id === 'sleepTimerModal') {
                    closeSleepTimer();
                }
            });

            // ========================================
            // CROSSFADE FUNCTIONS
            // ========================================
            function initCrossfade() {
                const crossfadeToggle = document.getElementById('crossfadeToggle');
                const crossfadeDurationSlider = document.getElementById('crossfadeDuration');
                const crossfadeDurationSection = document.getElementById('crossfadeDurationSection');
                const crossfadeDurationValue = document.getElementById('crossfadeDurationValue');
                
                if (crossfadeToggle) {
                    crossfadeToggle.addEventListener('change', (e) => {
                        crossfadeEnabled = e.target.checked;
                        if (crossfadeDurationSection) {
                            crossfadeDurationSection.classList.toggle('active', crossfadeEnabled);
                        }
                        console.log('Crossfade', crossfadeEnabled ? 'enabled' : 'disabled');
                    });
                }
                
                if (crossfadeDurationSlider) {
                    crossfadeDurationSlider.addEventListener('input', (e) => {
                        crossfadeDuration = parseInt(e.target.value);
                        if (crossfadeDurationValue) {
                            crossfadeDurationValue.textContent = crossfadeDuration + 's';
                        }
                    });
                }
            }
            
            function preloadNextTrack() {
                if (!crossfadeEnabled || crossfading) return;
                
                // Calculate next track index
                let nextIdx;
                if (isShuffled && isSmartShuffleEnabled) {
                    // Peek at next smart shuffle without consuming it
                    const scored = getSmartShuffleScored();
                    if (scored && scored.length > 0) {
                        const nextSong = scored[0];
                        nextIdx = tracks.findIndex(t => t.dataset.file === nextSong.name);
                    }
                } else if (isShuffled) {
                    nextIdx = Math.floor(Math.random() * tracks.length);
                } else {
                    nextIdx = currentIndex < tracks.length - 1 ? currentIndex + 1 : 0;
                }
                
                if (nextIdx >= 0 && nextIdx < tracks.length) {
                    const nextTrack = tracks[nextIdx];
                    if (!nextTrackAudio) {
                        nextTrackAudio = new Audio();
                        nextTrackAudio.volume = 0;
                    }
                    nextTrackAudio.src = nextTrack.dataset.src;
                    nextTrackAudio.load();
                }
            }
            
            function performCrossfade() {
                if (!crossfadeEnabled || crossfading || !nextTrackAudio || !nextTrackAudio.src) {
                    return false;
                }
                
                crossfading = true;
                const fadeTime = crossfadeDuration * 1000;
                const steps = 60; // 60 steps for smooth fade
                const stepTime = fadeTime / steps;
                let step = 0;
                
                const originalVolume = audio.volume;
                nextTrackAudio.volume = 0;
                
                // Start next track
                nextTrackAudio.play().catch(err => {
                    console.warn('Crossfade: Failed to play next track', err);
                    crossfading = false;
                    return;
                });
                
                const fadeInterval = setInterval(() => {
                    step++;
                    const progress = step / steps;
                    
                    // Fade out current
                    audio.volume = originalVolume * (1 - progress);
                    // Fade in next
                    nextTrackAudio.volume = originalVolume * progress;
                    
                    if (step >= steps) {
                        clearInterval(fadeInterval);
                        
                        // Switch to next track
                        audio.pause();
                        audio.src = nextTrackAudio.src;
                        audio.currentTime = nextTrackAudio.currentTime;
                        audio.volume = originalVolume;
                        
                        // Clear next track audio
                        nextTrackAudio.pause();
                        nextTrackAudio.src = '';
                        
                        crossfading = false;
                        
                        // Continue playing
                        audio.play();
                        
                        console.log('Crossfade completed');
                    }
                }, stepTime);
                
                return true;
            }

            // ========================================
            // MOBILE PLAYER FUNCTIONS
            // ========================================
            window.expandPlayer = function() {
                if (isMobile && playerSection) {
                    playerSection.classList.add('active');
                    document.body.classList.add('player-open');
                    document.body.style.overflow = 'hidden';
                }
            };
            
            window.collapsePlayer = function() {
                if (isMobile && playerSection) {
                    playerSection.classList.remove('active');
                    document.body.classList.remove('player-open');
                    document.body.style.overflow = '';
                }
            };
            
            window.shuffleAndPlay = function() {
                if (tracks.length > 0) {
                    isShuffled = true;
                    shuffleBtn.classList.add('active');
                    const randomIndex = Math.floor(Math.random() * tracks.length);
                    loadTrack(randomIndex);
                    audio.play();
                    isPlaying = true;
                    updatePlayIcon();
                }
            };
            
            function updateMiniPlayer() {
                if (miniPlayerArtwork) {
                    miniPlayerArtwork.src = artwork.src;
                }
                if (miniPlayerTitle) {
                    miniPlayerTitle.textContent = trackTitle.textContent;
                }
                if (miniPlayerArtist) {
                    miniPlayerArtist.textContent = trackArtist.textContent;
                }
                // Update ambient background
                const ambientImage = document.getElementById('ambientImage');
                if (ambientImage) {
                    ambientImage.src = artwork.src;
                }
                // Update ambient color for shuffle button
                updateAmbientColor(artwork.src);
            }
            
            // Extract dominant color from image and apply to shuffle button
            function updateAmbientColor(imageSrc) {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function() {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = 50;
                        canvas.height = 50;
                        ctx.drawImage(img, 0, 0, 50, 50);
                        
                        const imageData = ctx.getImageData(0, 0, 50, 50).data;
                        let r = 0, g = 0, b = 0, count = 0;
                        
                        // Sample pixels to get average color
                        for (let i = 0; i < imageData.length; i += 16) {
                            const red = imageData[i];
                            const green = imageData[i + 1];
                            const blue = imageData[i + 2];
                            const alpha = imageData[i + 3];
                            
                            // Skip very dark or very light pixels
                            const brightness = (red + green + blue) / 3;
                            if (alpha > 128 && brightness > 30 && brightness < 220) {
                                r += red;
                                g += green;
                                b += blue;
                                count++;
                            }
                        }
                        
                        if (count > 0) {
                            r = Math.round(r / count);
                            g = Math.round(g / count);
                            b = Math.round(b / count);
                            
                            // Boost saturation for more vibrant color
                            const max = Math.max(r, g, b);
                            const min = Math.min(r, g, b);
                            const boost = 1.3;
                            
                            if (max !== min) {
                                r = Math.min(255, Math.round(r * boost));
                                g = Math.min(255, Math.round(g * boost));
                                b = Math.min(255, Math.round(b * boost));
                            }
                            
                            const color = `rgb(${r}, ${g}, ${b})`;
                            const shadowColor = `rgba(${r}, ${g}, ${b}, 0.4)`;
                            
                            document.documentElement.style.setProperty('--ambient-color', color);
                            document.documentElement.style.setProperty('--ambient-shadow', shadowColor);
                        }
                    } catch (e) {
                        console.log('Could not extract color:', e);
                    }
                };
                img.src = imageSrc;
            }
            
            function updateMiniPlayerProgress() {
                const currentAudio = isStreamingPlayback ? streamingAudio : audio;
                if (miniPlayerProgress && currentAudio.duration) {
                    const percent = (currentAudio.currentTime / currentAudio.duration) * 100;
                    miniPlayerProgress.style.width = percent + '%';
                }
            }
            
            function updateMiniPlayIcon() {
                if (miniPlayIcon) {
                    if (isPlaying) {
                        miniPlayIcon.innerHTML = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>';
                    } else {
                        miniPlayIcon.innerHTML = '<path d="M8 5v14l11-7z"/>';
                    }
                }
            }
            
            // Global toggle play for mini player
            window.togglePlay = function() {
                if (isStreamingPlayback) {
                    // Toggle streaming audio
                    if (isPlaying) {
                        pause();
                    } else {
                        playStreaming();
                    }
                } else if (!audio.src && tracks.length) {
                    loadTrack(0);
                    play();
                } else if (isPlaying) {
                    pause();
                } else {
                    play();
                }
            };
            
            // Global play next for mini player
            window.playNext = function() {
                if (tracks.length === 0) return;
                let idx;
                if (isShuffled) {
                    idx = Math.floor(Math.random() * tracks.length);
                } else {
                    idx = currentIndex < tracks.length - 1 ? currentIndex + 1 : 0;
                }
                loadTrack(idx, true);
                play();
            };
            
            // Handle resize
            window.addEventListener('resize', () => {
                isMobile = window.innerWidth <= 768;
                if (!isMobile && playerSection) {
                    playerSection.classList.remove('active');
                    document.body.classList.remove('player-open');
                    document.body.style.overflow = '';
                }
            });
            
            // Library tab handling
            document.querySelectorAll('.library-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    document.querySelectorAll('.library-tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    // Tab functionality can be extended here
                });
            });

            // ========================================
            // CACHE PERSISTENCE - Save/Restore State
            // ========================================
            const CACHE_KEY = 'musify_player_state';
            
            function savePlayerState() {
                const state = {
                    trackIndex: currentIndex,
                    currentTime: audio.currentTime || 0,
                    volume: audio.volume,
                    isShuffled: isShuffled,
                    repeatMode: repeatMode,
                    wasPlaying: isPlaying,
                    timestamp: Date.now()
                };
                try {
                    localStorage.setItem(CACHE_KEY, JSON.stringify(state));
                } catch (e) {
                    console.warn('Could not save player state:', e);
                }
            }

            function loadPlayerState() {
                try {
                    const saved = localStorage.getItem(CACHE_KEY);
                    if (!saved) return null;
                    return JSON.parse(saved);
                } catch (e) {
                    console.warn('Could not load player state:', e);
                    return null;
                }
            }

            function restorePlayerState() {
                const state = loadPlayerState();
                if (!state || tracks.length === 0) return;

                // Restore shuffle mode
                if (state.isShuffled !== undefined) {
                    isShuffled = state.isShuffled;
                    if (typeof updateShuffleBtn === 'function') updateShuffleBtn();
                }

                // Restore repeat mode
                if (state.repeatMode !== undefined) {
                    repeatMode = state.repeatMode;
                    if (typeof updateRepeatBtn === 'function') updateRepeatBtn();
                }

                // Restore volume
                if (state.volume !== undefined) {
                    audio.volume = state.volume;
                    volumeSlider.value = state.volume * 100;
                }

                // Restore track and position
                if (state.trackIndex !== undefined && state.trackIndex >= 0 && state.trackIndex < tracks.length) {
                    loadTrack(state.trackIndex);
                    
                    // Wait for audio to load, then seek to saved position
                    const seekToSaved = () => {
                        if (state.currentTime > 0 && audio.duration) {
                            // Only restore if within valid duration
                            if (state.currentTime < audio.duration) {
                                audio.currentTime = state.currentTime;
                            }
                        }
                        // Auto-resume playback if it was playing (within last 30 minutes)
                        const thirtyMinutes = 30 * 60 * 1000;
                        if (state.wasPlaying && (Date.now() - state.timestamp) < thirtyMinutes) {
                            // Don't auto-play to respect browser policies, but show a resume button
                            // For now, we just restore the position without auto-playing
                        }
                    };
                    
                    if (audio.readyState >= 1) {
                        seekToSaved();
                    } else {
                        audio.addEventListener('loadedmetadata', seekToSaved, { once: true });
                    }
                }
            }

            // Save state periodically and on key events
            audio.addEventListener('timeupdate', () => {
                // Save every 5 seconds of playback
                if (Math.floor(audio.currentTime) % 5 === 0) {
                    savePlayerState();
                }
            });

            audio.addEventListener('pause', savePlayerState);
            audio.addEventListener('play', savePlayerState);
            audio.addEventListener('ended', savePlayerState);
            audio.addEventListener('volumechange', savePlayerState);

            // Save state before page unload
            window.addEventListener('beforeunload', savePlayerState);
            window.addEventListener('pagehide', savePlayerState);

            // ========================================
            // SMART RECOMMENDATION SYSTEM
            // ========================================
            let smartShuffleOrder = [];
            let smartShuffleIndex = 0;
            let trackStartTime = 0;
            let lastRecordedTrack = null;
            let isSmartShuffleEnabled = false;

            // Record play event to the recommendation engine
            async function recordPlayEvent(songName, completed, durationPlayed, totalDuration, skipped = false) {
                try {
                    await fetch('/api/recommend/record', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            song_name: songName,
                            completed: completed,
                            duration_played: durationPlayed,
                            total_duration: totalDuration,
                            skipped: skipped
                        })
                    });
                } catch (e) {
                    console.warn('Could not record play event:', e);
                }
            }

            // Fetch smart shuffle order from server
            async function fetchSmartShuffleOrder() {
                try {
                    const response = await fetch('/api/recommend/shuffle');
                    const data = await response.json();
                    if (data.order && data.order.length > 0) {
                        smartShuffleOrder = data.order;
                        smartShuffleIndex = 0;
                        console.log('Smart shuffle loaded:', smartShuffleOrder.length, 'songs');
                        return true;
                    }
                } catch (e) {
                    console.warn('Could not fetch smart shuffle order:', e);
                }
                return false;
            }

            // Get next track index using smart shuffle
            function getNextSmartShuffleIndex() {
                if (smartShuffleOrder.length === 0) {
                    return Math.floor(Math.random() * tracks.length);
                }
                
                smartShuffleIndex = (smartShuffleIndex + 1) % smartShuffleOrder.length;
                const nextSongName = smartShuffleOrder[smartShuffleIndex];
                
                // Find the track index by filename
                const trackIndex = tracks.findIndex(t => t.dataset.file === nextSongName);
                return trackIndex !== -1 ? trackIndex : Math.floor(Math.random() * tracks.length);
            }

            // Track when a song starts playing
            function onTrackStart() {
                trackStartTime = Date.now();
                lastRecordedTrack = tracks[currentIndex]?.dataset.file;
            }

            // Record when leaving a track (skip, next, or ended)
            function recordTrackLeave(completed = false, skipped = false) {
                if (lastRecordedTrack && trackStartTime > 0) {
                    const durationPlayed = (Date.now() - trackStartTime) / 1000;
                    const totalDuration = audio.duration || 0;
                    recordPlayEvent(lastRecordedTrack, completed, durationPlayed, totalDuration, skipped);
                }
                trackStartTime = 0;
            }

            // Play/Pause icon paths
            const playPath = 'M8 5v14l11-7z';
            const pausePath = 'M6 19h4V5H6v14zm8-14v14h4V5h-4z';

            // ========================================
            // STREAMING MODE & SEARCH
            // ========================================
            let isStreamingMode = false;
            let isStreamingPlayback = false; // True when playing streamed content
            let streamingQueue = [];
            let currentStreamingIndex = -1;
            let currentViewMode = 'list';

            // ========================================
            // STREAMING HISTORY CACHE
            // ========================================
            const STREAMING_HISTORY_KEY = 'musify_streaming_history';
            const MAX_HISTORY_ITEMS = 50;

            // Get streaming history from localStorage
            function getStreamingHistory() {
                try {
                    const history = localStorage.getItem(STREAMING_HISTORY_KEY);
                    return history ? JSON.parse(history) : [];
                } catch (e) {
                    console.warn('Could not load streaming history:', e);
                    return [];
                }
            }

            // Save a song to streaming history
            function saveToStreamingHistory(song) {
                try {
                    let history = getStreamingHistory();
                    
                    // Remove duplicate if exists (by videoId)
                    history = history.filter(item => item.videoId !== song.videoId);
                    
                    // Add new song to the beginning
                    history.unshift({
                        videoId: song.videoId,
                        title: song.title,
                        artist: song.artist || 'Unknown Artist',
                        thumbnail: song.thumbnail,
                        duration: song.duration,
                        playedAt: Date.now()
                    });
                    
                    // Limit history size
                    if (history.length > MAX_HISTORY_ITEMS) {
                        history = history.slice(0, MAX_HISTORY_ITEMS);
                    }
                    
                    localStorage.setItem(STREAMING_HISTORY_KEY, JSON.stringify(history));
                } catch (e) {
                    console.warn('Could not save to streaming history:', e);
                }
            }

            // Clear streaming history
            function clearStreamingHistory() {
                try {
                    localStorage.removeItem(STREAMING_HISTORY_KEY);
                    // Refresh the display
                    showSearchWithHistory();
                } catch (e) {
                    console.warn('Could not clear streaming history:', e);
                }
            }

            // Format relative time (e.g., "2 hours ago")
            function formatRelativeTime(timestamp) {
                const now = Date.now();
                const diff = now - timestamp;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);
                
                if (minutes < 1) return 'Just now';
                if (minutes < 60) return `${minutes}m ago`;
                if (hours < 24) return `${hours}h ago`;
                if (days < 7) return `${days}d ago`;
                return new Date(timestamp).toLocaleDateString();
            }

            // Display streaming history in search results
            function displayStreamingHistory() {
                const history = getStreamingHistory();
                if (!searchResults || history.length === 0) return '';
                
                let html = '<div class="search-section-title">Recently Played</div>';
                html += '<div class="history-clear-btn" onclick="clearStreamingHistory(); displayStreamingHistory();">Clear History</div>';
                html += history.slice(0, 10).map(song => `
                    <div class="search-result-item history-item" data-video-id="${song.videoId}" data-title="${song.title}">
                        <img class="search-result-thumb" src="${song.thumbnail || '/static/default-artwork.png'}" alt="${song.title}" onerror="this.src='/static/default-artwork.png'">
                        <div class="search-result-info">
                            <div class="search-result-title">${song.title}</div>
                            <div class="search-result-meta">
                                <span class="search-result-channel">${song.artist}</span>
                                <span class="search-result-time">${formatRelativeTime(song.playedAt)}</span>
                            </div>
                        </div>
                        <button class="search-result-play" title="Play">
                            <svg viewBox="0 0 24 24" width="20" height="20">
                                <path fill="currentColor" d="M8 5v14l11-7z"/>
                            </svg>
                        </button>
                    </div>
                `).join('');
                
                return html;
            }

            // Show history when opening search with no query
            function showSearchWithHistory() {
                const historyHtml = displayStreamingHistory();
                
                // Update search overlay results
                if (searchResults) {
                    if (historyHtml) {
                        searchResults.innerHTML = historyHtml;
                        attachHistoryClickHandlers();
                    } else {
                        searchResults.innerHTML = '<div class="search-hint"><svg viewBox="0 0 24 24" width="48" height="48" fill="currentColor" opacity="0.3"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/></svg><p>Search for songs to stream</p></div>';
                    }
                }
                
                // Also update the search page content area
                const searchContent = document.getElementById('searchContent');
                if (searchContent) {
                    if (historyHtml) {
                        searchContent.innerHTML = historyHtml;
                        // Attach handlers for this container too
                        searchContent.querySelectorAll('.history-item').forEach(item => {
                            item.addEventListener('click', () => {
                                const videoId = item.dataset.videoId;
                                const title = item.dataset.title;
                                playStreamingTrack(videoId, title);
                                hideSearchPage();
                            });
                        });
                    } else {
                        searchContent.innerHTML = '<div class="search-section-title">Start typing to search...</div><div id="searchResultsContainer"></div>';
                    }
                }
            }

            // Attach click handlers to history items
            function attachHistoryClickHandlers() {
                if (!searchResults) return;
                searchResults.querySelectorAll('.history-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const videoId = item.dataset.videoId;
                        const title = item.dataset.title;
                        playStreamingTrack(videoId, title);
                        closeSearchOverlay();
                    });
                });
            }
            
            // DOM elements for new features
            const searchOverlay = document.getElementById('searchOverlay');
            const searchOverlayInput = document.getElementById('searchOverlayInput');
            const searchResults = document.getElementById('searchResults');
            const closeSearchBtn = document.getElementById('closeSearchBtn');
            const searchPageBtn = document.getElementById('searchPageBtn');
            const streamToggle = document.getElementById('streamingToggle');
            const similarQueue = document.getElementById('similarQueue');
            const similarList = document.getElementById('similarList');
            const viewModeList = document.getElementById('viewModeList');
            const viewModeGrid = document.getElementById('viewModeGrid');
            const viewModeCompact = document.getElementById('viewModeCompact');
            
            // Open search overlay
            function openSearchOverlay() {
                if (searchOverlay) {
                    searchOverlay.classList.add('active');
                    searchOverlayInput?.focus();
                    // Show history if no search query
                    showSearchWithHistory();
                }
            }
            
            // Close search overlay
            function closeSearchOverlay() {
                if (searchOverlay) {
                    searchOverlay.classList.remove('active');
                    if (searchOverlayInput) searchOverlayInput.value = '';
                    if (searchResults) searchResults.innerHTML = '';
                }
            }
            
            // Search YouTube for songs with offline fallback
            async function searchYouTube(query) {
                if (!query.trim()) return;
                
                if (searchResults) {
                    searchResults.innerHTML = '<div class="search-loading">Searching...</div>';
                }
                
                // First, search local library
                const localResults = searchLocalLibrary(query);
                
                try {
                    const response = await fetch(`/api/stream/search?q=${encodeURIComponent(query)}`);
                    const data = await response.json();
                    
                    if (data.results && data.results.length > 0) {
                        displaySearchResults(data.results, localResults);
                    } else if (localResults.length > 0) {
                        // Fallback to local results only
                        displaySearchResults([], localResults);
                    } else {
                        if (searchResults) {
                            searchResults.innerHTML = '<div class="search-empty">No results found</div>';
                        }
                    }
                } catch (e) {
                    console.error('Online search failed, using offline:', e);
                    // Fallback to local library on network error
                    if (localResults.length > 0) {
                        displaySearchResults([], localResults);
                    } else if (searchResults) {
                        searchResults.innerHTML = '<div class="search-error">Offline. No local matches found.</div>';
                    }
                }
            }

            // Search local library
            function searchLocalLibrary(query) {
                const q = query.toLowerCase().trim();
                const results = [];
                tracks.forEach((track, index) => {
                    const title = (track.dataset.title || '').toLowerCase();
                    if (title.includes(q)) {
                        results.push({
                            index: index,
                            title: track.dataset.title,
                            file: track.dataset.file,
                            isLocal: true
                        });
                    }
                });
                return results.slice(0, 10);
            }
            
            // Display search results (online + offline)
            function displaySearchResults(onlineResults, localResults = []) {
                if (!searchResults) return;
                
                let html = '';
                
                // Show local results first if available
                if (localResults.length > 0) {
                    html += '<div class="search-section-title">From Your Library</div>';
                    html += localResults.map(r => `
                        <div class="search-result-item local-result" data-local-index="${r.index}" data-title="${r.title}">
                            <img class="search-result-thumb" src="/cover/${encodeURIComponent(r.file)}" alt="${r.title}" onerror="this.src='/static/default-artwork.png'">
                            <div class="search-result-info">
                                <div class="search-result-title">${r.title}</div>
                                <div class="search-result-meta">
                                    <span class="search-result-channel">Local Library</span>
                                </div>
                            </div>
                            <button class="search-result-play" title="Play">
                                <svg viewBox="0 0 24 24" width="20" height="20">
                                    <path fill="currentColor" d="M8 5v14l11-7z"/>
                                </svg>
                            </button>
                        </div>
                    `).join('');
                }
                
                // Show online results
                if (onlineResults.length > 0) {
                    if (localResults.length > 0) {
                        html += '<div class="search-section-title">Stream Online</div>';
                    }
                    html += onlineResults.map(r => `
                        <div class="search-result-item" data-video-id="${r.id}" data-title="${r.title}" data-duration="${r.duration}">
                            <img class="search-result-thumb" src="${r.thumbnail}" alt="${r.title}">
                            <div class="search-result-info">
                                <div class="search-result-title">${r.title}</div>
                                <div class="search-result-meta">
                                    <span class="search-result-channel">${r.channel}</span>
                                    <span class="search-result-duration">${r.duration}</span>
                                </div>
                            </div>
                            <button class="search-result-play" title="Play">
                                <svg viewBox="0 0 24 24" width="20" height="20">
                                    <path fill="currentColor" d="M8 5v14l11-7z"/>
                                </svg>
                            </button>
                        </div>
                    `).join('');
                }
                
                searchResults.innerHTML = html;
                
                // Add click handlers
                searchResults.querySelectorAll('.search-result-item').forEach(item => {
                    item.addEventListener('click', () => {
                        if (item.classList.contains('local-result')) {
                            // Play from local library
                            const localIndex = parseInt(item.dataset.localIndex);
                            exitStreamingPlayback();
                            loadTrack(localIndex);
                            play();
                        } else {
                            // Play from streaming
                            const videoId = item.dataset.videoId;
                            const title = item.dataset.title;
                            playStreamingTrack(videoId, title);
                        }
                        closeSearchOverlay();
                    });
                });
            }

            // Exit streaming playback mode (go back to library-only playback)
            function exitStreamingPlayback() {
                // Turn off streaming playback and streaming mode so next/ended plays use library
                isStreamingPlayback = false;
                isStreamingMode = false;
                streamingQueue = [];

                // Stop and clear streaming audio, switch back to main audio element
                streamingAudio.pause();
                streamingAudio.src = '';
                activeAudio = audio;

                // Hide similar/upnext UI
                if (similarQueue) {
                    similarQueue.classList.remove('active');
                }

                // Update UI toggles
                document.body.classList.remove('queue-open');
                document.body.classList.remove('streaming-mode');
                if (streamToggle) streamToggle.classList.remove('active');
                const headerToggle = document.getElementById('streamModeToggle');
                if (headerToggle) headerToggle.checked = false;
                const streamIndicator = document.getElementById('streamIndicator');
                if (streamIndicator) streamIndicator.style.opacity = 0.3;

                // Persist streaming mode preference
                try { localStorage.setItem('musify_streaming_mode', 'false'); } catch (e) {}
            }
            
            // Play a streaming track
            async function playStreamingTrack(videoId, title) {
                // Enter streaming playback mode and enable streaming mode
                isStreamingPlayback = true;
                isStreamingMode = true;

                // Persist streaming mode preference
                try { localStorage.setItem('musify_streaming_mode', 'true'); } catch (e) {}

                // Stop the library audio and switch to streaming audio element
                // This avoids CORS issues - streamingAudio is never connected to Wave Engine
                audio.pause();
                audio.src = '';
                activeAudio = streamingAudio;

                try {
                    // Get stream URL - using correct endpoint
                    const response = await fetch(`/api/stream/url/${videoId}`);
                    const data = await response.json();
                    
                    if (data.error) {
                        console.error('Stream error:', data.error);
                        alert('Could not load stream: ' + data.error);
                        return;
                    }
                    
                    if (data.stream_url) {
                        streamingAudio.src = data.stream_url;
                        trackTitle.textContent = title || data.title || 'Streaming...';
                        trackArtist.textContent = data.artist || 'YouTube';
                        
                        // Set thumbnail
                        if (data.thumbnail) {
                            artwork.src = data.thumbnail;
                            updateAmbient(data.thumbnail);
                            // Update ambient image for player background
                            const ambientImage = document.getElementById('ambientImage');
                            if (ambientImage) {
                                ambientImage.src = data.thumbnail;
                            }
                        }
                        
                        // Save to streaming history cache
                        saveToStreamingHistory({
                            videoId: videoId,
                            title: title || data.title || 'Unknown',
                            artist: data.artist || 'YouTube',
                            thumbnail: data.thumbnail,
                            duration: data.duration
                        });
                        
                        // Update mini player for streaming
                        updateMiniPlayer();
                        // Mark body as streaming-mode and show UI
                        document.body.classList.add('streaming-mode');
                        if (streamToggle) streamToggle.classList.add('active');
                        
                        playStreaming();
                        
                        // Load similar songs (upnext streaming queue)
                        loadSimilarSongs(videoId);
                        
                        // Update document title
                        document.title = `${title || data.title} â€” Musify Stream`;
                    } else {
                        console.error('No stream URL returned:', data);
                        alert('Could not load stream. Try another song.');
                    }
                } catch (e) {
                    console.error('Streaming failed:', e);
                    alert('Streaming failed. Check your connection.');
                }
            }
            
            // Load similar songs for current streaming track
            async function loadSimilarSongs(videoId) {
                if (!similarQueue || !similarList) return;
                
                similarList.innerHTML = '<div class="similar-loading">Loading similar songs...</div>';
                similarQueue.classList.add('active');
                
                try {
                    const response = await fetch(`/api/stream/similar/${videoId}`);
                    const data = await response.json();
                    
                    if (data.similar && data.similar.length > 0) {
                        streamingQueue = data.similar;
                        displaySimilarSongs(data.similar);
                    } else {
                        similarList.innerHTML = '<div class="similar-empty">No similar songs found</div>';
                    }
                } catch (e) {
                    console.error('Failed to load similar songs:', e);
                    similarList.innerHTML = '<div class="similar-error">Failed to load similar songs</div>';
                }
            }
            
            // Display similar songs queue
            function displaySimilarSongs(songs) {
                if (!similarList) return;
                
                similarList.innerHTML = songs.slice(0, 10).map((s, i) => `
                    <div class="similar-item" data-video-id="${s.id}" data-title="${s.title}" data-index="${i}">
                        <img class="similar-thumb" src="${s.thumbnail}" alt="${s.title}">
                        <div class="similar-info">
                            <div class="similar-title">${s.title}</div>
                            <div class="similar-channel">${s.channel}</div>
                        </div>
                    </div>
                `).join('');
                
                // Add click handlers
                similarList.querySelectorAll('.similar-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const videoId = item.dataset.videoId;
                        const title = item.dataset.title;
                        playStreamingTrack(videoId, title);
                    });
                });
            }
            
            // Toggle streaming mode
            function toggleStreamingMode(forceState = null) {
                if (forceState !== null) {
                    isStreamingMode = forceState;
                } else {
                    isStreamingMode = !isStreamingMode;
                }
                document.body.classList.toggle('streaming-mode', isStreamingMode);
                
                // Sync with sidebar toggle
                if (streamToggle) {
                    streamToggle.classList.toggle('active', isStreamingMode);
                }
                
                // Sync with header toggle checkbox
                const headerToggle = document.getElementById('streamModeToggle');
                if (headerToggle) {
                    headerToggle.checked = isStreamingMode;
                }
                
                // Update stream indicator
                const streamIndicator = document.getElementById('streamIndicator');
                if (streamIndicator) {
                    streamIndicator.style.opacity = isStreamingMode ? '1' : '0.3';
                }
                
                // Show/hide similar queue based on streaming mode
                if (similarQueue) {
                    similarQueue.classList.toggle('active', isStreamingMode && streamingQueue.length > 0);
                }
                
                // Save preference
                localStorage.setItem('musify_streaming_mode', isStreamingMode);
            }
            
            // Change view mode
            function setViewMode(mode) {
                currentViewMode = mode;
                playlist.className = 'playlist ' + mode + '-view';
                
                // Update button states
                [viewModeList, viewModeGrid, viewModeCompact].forEach(btn => {
                    btn?.classList.remove('active');
                });
                
                if (mode === 'list' && viewModeList) viewModeList.classList.add('active');
                if (mode === 'grid' && viewModeGrid) viewModeGrid.classList.add('active');
                if (mode === 'compact' && viewModeCompact) viewModeCompact.classList.add('active');
                
                localStorage.setItem('musify_view_mode', mode);
            }
            
            // Initialize streaming mode from saved preference
            function initStreamingMode() {
                const savedMode = localStorage.getItem('musify_streaming_mode');
                if (savedMode === 'true') {
                    toggleStreamingMode(true);
                }
                
                const savedViewMode = localStorage.getItem('musify_view_mode');
                if (savedViewMode) {
                    setViewMode(savedViewMode);
                }
                
                // Initialize stream indicator
                const streamIndicator = document.getElementById('streamIndicator');
                if (streamIndicator) {
                    streamIndicator.style.opacity = isStreamingMode ? '1' : '0.3';
                }
            }
            
            // Event listeners for search overlay
            if (searchPageBtn) {
                searchPageBtn.addEventListener('click', openSearchOverlay);
            }
            
            if (closeSearchBtn) {
                closeSearchBtn.addEventListener('click', closeSearchOverlay);
            }
            
            if (searchOverlayInput) {
                let searchTimeout;
                searchOverlayInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        searchYouTube(e.target.value);
                    }, 500);
                });
                
                searchOverlayInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        clearTimeout(searchTimeout);
                        searchYouTube(e.target.value);
                    }
                });
            }
            
            if (searchOverlay) {
                searchOverlay.addEventListener('click', (e) => {
                    if (e.target === searchOverlay) {
                        closeSearchOverlay();
                    }
                });
            }

            // Mobile library search button
            const searchLibraryBtn = document.getElementById('searchLibraryBtn');
            if (searchLibraryBtn) {
                searchLibraryBtn.addEventListener('click', openSearchOverlay);
            }

            // Like button functionality
            const trackLikeBtn = document.getElementById('trackLikeBtn');
            const trackLikeBtnHeader = document.getElementById('trackLikeBtnHeader');
            let likedTracks = JSON.parse(localStorage.getItem('likedTracks') || '[]');

            function isTrackLiked(trackFile) {
                return likedTracks.includes(trackFile);
            }

            function toggleLike() {
                if (currentIndex === -1 || !tracks[currentIndex]) return;
                const trackFile = tracks[currentIndex].dataset.file;
                const isLiked = isTrackLiked(trackFile);
                
                if (isLiked) {
                    likedTracks = likedTracks.filter(f => f !== trackFile);
                } else {
                    likedTracks.push(trackFile);
                }
                
                localStorage.setItem('likedTracks', JSON.stringify(likedTracks));
                updateLikeButtons();
            }

            function updateLikeButtons() {
                if (currentIndex === -1 || !tracks[currentIndex]) return;
                const isLiked = isTrackLiked(tracks[currentIndex].dataset.file);
                
                if (trackLikeBtn) {
                    trackLikeBtn.classList.toggle('active', isLiked);
                    trackLikeBtn.style.color = isLiked ? '#ff4757' : '';
                }
                if (trackLikeBtnHeader) {
                    trackLikeBtnHeader.classList.toggle('active', isLiked);
                    trackLikeBtnHeader.style.color = isLiked ? '#ff4757' : '';
                }
            }

            if (trackLikeBtn) {
                trackLikeBtn.addEventListener('click', toggleLike);
            }
            if (trackLikeBtnHeader) {
                trackLikeBtnHeader.addEventListener('click', toggleLike);
            }
            
            // Event listener for stream toggle
            if (streamToggle) {
                streamToggle.addEventListener('click', () => toggleStreamingMode());
            }
            
            // Event listener for header stream toggle checkbox
            const headerStreamToggle = document.getElementById('streamModeToggle');
            if (headerStreamToggle) {
                headerStreamToggle.addEventListener('change', (e) => {
                    toggleStreamingMode(e.target.checked);
                });
            }
            
            // Close similar queue button
            const closeSimilarQueueBtn = document.getElementById('closeSimilarQueue');
            if (closeSimilarQueueBtn) {
                closeSimilarQueueBtn.addEventListener('click', () => {
                    if (similarQueue) similarQueue.classList.remove('active');
                    document.body.classList.remove('queue-open');
                });
            }
            
            // Event listeners for view mode buttons
            if (viewModeList) viewModeList.addEventListener('click', () => setViewMode('list'));
            if (viewModeGrid) viewModeGrid.addEventListener('click', () => setViewMode('grid'));
            if (viewModeCompact) viewModeCompact.addEventListener('click', () => setViewMode('compact'));
            
            // Auto-play next song when current ends
            audio.addEventListener('ended', () => {
                // Check if we're in streaming playback mode
                if (isStreamingPlayback && streamingQueue.length > 0) {
                    // Play next from streaming queue
                    const nextSong = streamingQueue.shift();
                    if (nextSong) {
                        playStreamingTrack(nextSong.id, nextSong.title);
                        displaySimilarSongs(streamingQueue);
                    }
                } else if (!isStreamingPlayback) {
                    // Play next from local library
                    playNext();
                }
            });
            
            // Initialize streaming mode on load
            setTimeout(initStreamingMode, 100);
            
            // Initialize crossfade
            initCrossfade();

            // ========================================
            // WAVE ENGINE INTEGRATION
            // ========================================
            let waveEngine = null;
            const waveEnginePanel = document.getElementById('waveEnginePanel');
            const waveEngineToggle = document.getElementById('waveEngineToggle');
            const waveEngineClose = document.getElementById('waveEngineClose');
            const waveEngineEnabled = document.getElementById('waveEngineEnabled');
            const waveVisualizer = document.getElementById('waveVisualizer');
            let visualizerCtx = waveVisualizer?.getContext('2d');
            let visualizerAnimationId = null;

            // Initialize Wave Engine
            async function initWaveEngine() {
                if (waveEngine) return;
                
                try {
                    waveEngine = new WaveEngine();
                    await waveEngine.init(audio);
                    
                    // Load saved settings
                    const savedSettings = localStorage.getItem('waveEngineSettings');
                    if (savedSettings) {
                        const settings = JSON.parse(savedSettings);
                        waveEngine.loadSettings(settings);
                        updateWaveEngineUI(settings);
                    }
                    
                    console.log('ðŸŽµ Wave Engine initialized successfully');
                } catch (e) {
                    console.error('Failed to initialize Wave Engine:', e);
                }
            }

            // Toggle Wave Engine panel
            async function toggleWaveEnginePanel() {
                if (!waveEngine) {
                    await initWaveEngine();
                }
                waveEnginePanel.classList.toggle('active');
                waveEngineToggle?.classList.toggle('active');
                waveEngineToggleMobile?.classList.toggle('active');
                
                if (waveEnginePanel.classList.contains('active')) {
                    startVisualizer();
                } else {
                    stopVisualizer();
                }
            }

            const waveEngineToggleMobile = document.getElementById('waveEngineToggleMobile');

            if (waveEngineToggle) {
                waveEngineToggle.addEventListener('click', toggleWaveEnginePanel);
            }

            if (waveEngineToggleMobile) {
                waveEngineToggleMobile.addEventListener('click', toggleWaveEnginePanel);
            }

            if (waveEngineClose) {
                waveEngineClose.addEventListener('click', () => {
                    waveEnginePanel.classList.remove('active');
                    waveEngineToggle?.classList.remove('active');
                    waveEngineToggleMobile?.classList.remove('active');
                    stopVisualizer();
                });
            }

            // Wave Engine enabled toggle
            if (waveEngineEnabled) {
                waveEngineEnabled.addEventListener('change', (e) => {
                    if (waveEngine) {
                        waveEngine.setEnabled(e.target.checked);
                        saveWaveEngineSettings();
                    }
                });
            }

            // Preset buttons
            const wavePresets = document.getElementById('wavePresets');
            if (wavePresets) {
                wavePresets.addEventListener('click', async (e) => {
                    if (e.target.classList.contains('wave-preset')) {
                        if (!waveEngine) await initWaveEngine();
                        
                        wavePresets.querySelectorAll('.wave-preset').forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        const preset = e.target.dataset.preset;
                        waveEngine.setPreset(preset);
                        updateWaveEngineUI(waveEngine.getSettings());
                        saveWaveEngineSettings();
                    }
                });
            }

            // Acoustic Color sliders
            const colorSliders = {
                waveWarmth: 'warmth',
                waveBrightness: 'brightness',
                waveBody: 'body',
                waveAir: 'air',
                wavePunch: 'punch'
            };

            Object.entries(colorSliders).forEach(([id, param]) => {
                const slider = document.getElementById(id);
                const valueDisplay = document.getElementById(id + 'Val');
                
                if (slider) {
                    slider.addEventListener('input', async (e) => {
                        if (!waveEngine) await initWaveEngine();
                        
                        const value = e.target.value / 100;
                        if (valueDisplay) valueDisplay.textContent = e.target.value + '%';
                        
                        waveEngine.setColor({ [param]: value });
                        saveWaveEngineSettings();
                    });
                }
            });

            // Spatial sliders
            const spatialWidthSlider = document.getElementById('waveSpatialWidth');
            const spatialWidthVal = document.getElementById('waveSpatialWidthVal');
            const spatialDepthSlider = document.getElementById('waveSpatialDepth');
            const spatialDepthVal = document.getElementById('waveSpatialDepthVal');
            const waveRoom = document.getElementById('waveRoom');

            if (spatialWidthSlider) {
                spatialWidthSlider.addEventListener('input', async (e) => {
                    if (!waveEngine) await initWaveEngine();
                    
                    const value = e.target.value / 100;
                    if (spatialWidthVal) spatialWidthVal.textContent = e.target.value + '%';
                    
                    waveEngine.setSpatial({ width: value });
                    saveWaveEngineSettings();
                });
            }

            if (spatialDepthSlider) {
                spatialDepthSlider.addEventListener('input', async (e) => {
                    if (!waveEngine) await initWaveEngine();
                    
                    const value = e.target.value / 100;
                    if (spatialDepthVal) spatialDepthVal.textContent = e.target.value + '%';
                    
                    waveEngine.setSpatial({ depth: value });
                    saveWaveEngineSettings();
                });
            }

            if (waveRoom) {
                waveRoom.addEventListener('change', async (e) => {
                    if (!waveEngine) await initWaveEngine();
                    
                    waveEngine.setSpatial({ room: e.target.value });
                    saveWaveEngineSettings();
                });
            }

            // Dynamics mode buttons
            const waveDynamicsModes = document.getElementById('waveDynamicsModes');
            if (waveDynamicsModes) {
                waveDynamicsModes.addEventListener('click', async (e) => {
                    if (e.target.classList.contains('wave-dynamics-btn')) {
                        if (!waveEngine) await initWaveEngine();
                        
                        waveDynamicsModes.querySelectorAll('.wave-dynamics-btn').forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        const mode = e.target.dataset.mode;
                        waveEngine.setDynamics({ mode });
                        saveWaveEngineSettings();
                    }
                });
            }

            // Update UI from settings
            function updateWaveEngineUI(settings) {
                if (!settings) return;

                // Update color sliders
                if (settings.color) {
                    Object.entries(colorSliders).forEach(([id, param]) => {
                        const slider = document.getElementById(id);
                        const valueDisplay = document.getElementById(id + 'Val');
                        if (slider && settings.color[param] !== undefined) {
                            const val = Math.round(settings.color[param] * 100);
                            slider.value = val;
                            if (valueDisplay) valueDisplay.textContent = val + '%';
                        }
                    });
                }

                // Update spatial sliders
                if (settings.spatial) {
                    if (spatialWidthSlider && settings.spatial.width !== undefined) {
                        const val = Math.round(settings.spatial.width * 100);
                        spatialWidthSlider.value = val;
                        if (spatialWidthVal) spatialWidthVal.textContent = val + '%';
                    }
                    if (spatialDepthSlider && settings.spatial.depth !== undefined) {
                        const val = Math.round(settings.spatial.depth * 100);
                        spatialDepthSlider.value = val;
                        if (spatialDepthVal) spatialDepthVal.textContent = val + '%';
                    }
                    if (waveRoom && settings.spatial.room) {
                        waveRoom.value = settings.spatial.room;
                    }
                }

                // Update dynamics mode
                if (settings.dynamics && settings.dynamics.mode) {
                    waveDynamicsModes?.querySelectorAll('.wave-dynamics-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.mode === settings.dynamics.mode);
                    });
                }

                // Update preset selection
                if (settings.preset) {
                    wavePresets?.querySelectorAll('.wave-preset').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.preset === settings.preset);
                    });
                }
            }

            // Save settings to localStorage
            function saveWaveEngineSettings() {
                if (waveEngine) {
                    localStorage.setItem('waveEngineSettings', JSON.stringify(waveEngine.getSettings()));
                }
            }

            // Visualizer
            function startVisualizer() {
                if (!waveEngine || !waveVisualizer || !visualizerCtx) return;
                
                const width = waveVisualizer.width = waveVisualizer.offsetWidth * 2;
                const height = waveVisualizer.height = waveVisualizer.offsetHeight * 2;
                
                function draw() {
                    if (!waveEnginePanel.classList.contains('active')) return;
                    
                    const data = waveEngine.getVisualizationData();
                    
                    visualizerCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    visualizerCtx.fillRect(0, 0, width, height);
                    
                    // Draw spectrum bars
                    const barCount = 64;
                    const barWidth = width / barCount;
                    const gradient = visualizerCtx.createLinearGradient(0, height, 0, 0);
                    gradient.addColorStop(0, '#8b5cf6');
                    gradient.addColorStop(0.5, '#a855f7');
                    gradient.addColorStop(1, '#d946ef');
                    
                    visualizerCtx.fillStyle = gradient;
                    
                    for (let i = 0; i < barCount; i++) {
                        const dataIndex = Math.floor(i * (data.spectrum.length / barCount));
                        const value = data.spectrum[dataIndex];
                        const barHeight = value * height * 0.9;
                        
                        const x = i * barWidth;
                        const y = height - barHeight;
                        
                        visualizerCtx.beginPath();
                        visualizerCtx.roundRect(x + 1, y, barWidth - 2, barHeight, 2);
                        visualizerCtx.fill();
                    }
                    
                    visualizerAnimationId = requestAnimationFrame(draw);
                }
                
                draw();
            }

            function stopVisualizer() {
                if (visualizerAnimationId) {
                    cancelAnimationFrame(visualizerAnimationId);
                    visualizerAnimationId = null;
                }
            }

            // Resume audio context on first interaction
            document.addEventListener('click', async () => {
                if (waveEngine) {
                    await waveEngine.resume();
                }
            }, { once: true });

            // Search functionality
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase().trim();
                const allItems = playlist.querySelectorAll('.playlist-item[data-src]');
                allItems.forEach(item => {
                    const title = (item.dataset.title || '').toLowerCase();
                    if (query === '' || title.includes(query)) {
                        item.classList.remove('hidden');
                    } else {
                        item.classList.add('hidden');
                    }
                });
            });

            function formatTime(seconds) {
                if (!isFinite(seconds)) return '00:00';
                const m = Math.floor(seconds / 60);
                const s = Math.floor(seconds % 60);
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }

            function updateAmbient(imgSrc) {
                ambientImg.src = imgSrc;
            }

            function updatePlayIcon() {
                if (isPlaying) {
                    playIconPath.setAttribute('d', pausePath);
                    playBtn.classList.add('playing');
                } else {
                    playIconPath.setAttribute('d', playPath);
                    playBtn.classList.remove('playing');
                }
                // Update mini player icon too
                updateMiniPlayIcon();
            }

            function loadTrack(index, isSkip = false) {
                if (index < 0 || index >= tracks.length) return;
                
                // Record leaving the previous track
                if (currentIndex !== -1 && currentIndex !== index) {
                    recordTrackLeave(false, isSkip);
                }
                
                const li = tracks[index];
                const src = li.dataset.src;
                const title = li.dataset.title || 'Unknown';
                const file = li.dataset.file;
                const coverUrl = '/cover/' + encodeURIComponent(file);

                audio.src = src;
                trackTitle.textContent = title;
                trackArtist.textContent = '<unknown>';
                artwork.src = coverUrl;
                updateAmbient(coverUrl);
                currentIndex = index;
                highlightCurrent();

                // Update document title
                document.title = `${title} â€” Musify`;
                
                // Update mini player
                updateMiniPlayer();
                
                // Update like button state
                updateLikeButtons();
                
                // Start tracking new song
                onTrackStart();
            }

            function highlightCurrent() {
                tracks.forEach((t, i) => t.classList.toggle('active', i === currentIndex));
            }

            function updateMiniProgress() {
                const currentAudio = isStreamingPlayback ? streamingAudio : audio;
                tracks.forEach((t, i) => {
                    const bar = t.querySelector('.mini-progress-bar');
                    if (!bar) return;
                    if (i === currentIndex && !isStreamingPlayback && currentAudio.duration) {
                        const pct = (currentAudio.currentTime / currentAudio.duration) * 100;
                        bar.style.width = pct + '%';
                    } else {
                        bar.style.width = '0%';
                    }
                });
                // Also update the floating mini player progress
                updateMiniPlayerProgress();
            }

            function play() {
                if (!audio.src) return;
                
                // Auto-initialize Wave Engine on first play (skip for streaming due to CORS)
                if (!waveEngine && typeof WaveEngine !== 'undefined' && !isStreamingPlayback) {
                    initWaveEngine();
                }
                
                const p = audio.play();
                if (p && p.then) {
                    p.then(() => {
                        isPlaying = true;
                        updatePlayIcon();
                        if ('mediaSession' in navigator) {
                            navigator.mediaSession.playbackState = 'playing';
                        }
                        // Resume Wave Engine audio context
                        if (waveEngine) {
                            waveEngine.resume();
                        }
                    }).catch(err => console.warn('Playback failed:', err));
                }
            }

            function pause() {
                activeAudio.pause();
                isPlaying = false;
                updatePlayIcon();
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'paused';
                }
            }
            
            // Play streaming audio (separate audio element, no Wave Engine)
            function playStreaming() {
                if (!streamingAudio.src) return;
                
                const p = streamingAudio.play();
                if (p && p.then) {
                    p.then(() => {
                        isPlaying = true;
                        updatePlayIcon();
                        if ('mediaSession' in navigator) {
                            navigator.mediaSession.playbackState = 'playing';
                        }
                    }).catch(err => console.warn('Streaming playback failed:', err));
                }
            }

            // Event Listeners
            playlist.addEventListener('click', (e) => {
                // Handle trending items (ON_HOST mode - stream from YouTube)
                const trendingLi = e.target.closest('.playlist-item.trending-item[data-video-id]');
                if (trendingLi) {
                    const videoId = trendingLi.dataset.videoId;
                    const title = trendingLi.dataset.title;
                    const artist = trendingLi.dataset.artist;
                    const thumbnail = trendingLi.dataset.thumbnail;
                    
                    // Highlight the trending item
                    document.querySelectorAll('.playlist-item').forEach(item => item.classList.remove('active'));
                    trendingLi.classList.add('active');
                    
                    // Play the streaming track
                    playStreamingTrack(videoId, title);
                    
                    // On mobile, expand the player
                    if (isMobile) {
                        expandPlayer();
                    }
                    return;
                }
                
                // Handle local library items
                const li = e.target.closest('.playlist-item[data-src]');
                if (!li) return;
                const index = tracks.indexOf(li);
                if (index !== -1) {
                    // If user explicitly plays from library, exit streaming playback
                    exitStreamingPlayback();
                    loadTrack(index);
                    play();
                    // On mobile, expand the player
                    if (isMobile) {
                        expandPlayer();
                    }
                }
            });

            playBtn.addEventListener('click', () => {
                if (isStreamingPlayback) {
                    // Toggle streaming audio
                    if (isPlaying) pause(); else playStreaming();
                } else {
                    if (!audio.src && tracks.length) loadTrack(0);
                    if (isPlaying) pause(); else play();
                }
            });

            prevBtn.addEventListener('click', () => {
                if (tracks.length === 0) return;
                const idx = currentIndex > 0 ? currentIndex - 1 : tracks.length - 1;
                loadTrack(idx, true);  // Mark as skip
                play();
            });

            nextBtn.addEventListener('click', () => {
                if (tracks.length === 0) return;
                let idx;
                if (isShuffled && isSmartShuffleEnabled) {
                    idx = getNextSmartShuffleIndex();
                } else if (isShuffled) {
                    idx = Math.floor(Math.random() * tracks.length);
                } else {
                    idx = currentIndex < tracks.length - 1 ? currentIndex + 1 : 0;
                }
                loadTrack(idx, true);  // Mark as skip
                play();
            });

            audio.addEventListener('timeupdate', () => {
                if (!audio.duration) return;
                const percent = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = percent + '%';
                currentTimeEl.textContent = formatTime(audio.currentTime);
                updateMiniProgress();
                
                // Crossfade: preload next track when near end
                const timeRemaining = audio.duration - audio.currentTime;
                if (crossfadeEnabled && !crossfading && timeRemaining <= crossfadeDuration + 2 && timeRemaining > crossfadeDuration) {
                    preloadNextTrack();
                }
                
                // Crossfade: start crossfade at the right time
                if (crossfadeEnabled && !crossfading && timeRemaining <= crossfadeDuration && timeRemaining > 0.5) {
                    const crossfadeStarted = performCrossfade();
                    if (crossfadeStarted) {
                        // Move to next track in playlist
                        let idx;
                        if (isShuffled && isSmartShuffleEnabled) {
                            idx = getNextSmartShuffleIndex();
                        } else if (isShuffled) {
                            idx = Math.floor(Math.random() * tracks.length);
                        } else {
                            idx = currentIndex < tracks.length - 1 ? currentIndex + 1 : 0;
                        }
                        currentIndex = idx;
                        highlightCurrent();
                        updateNowPlayingUI(tracks[idx]);
                        recordTrackLeave(true, false); // Record previous track
                        onTrackStart(); // Start tracking new track
                    }
                }
            });

            audio.addEventListener('loadedmetadata', () => {
                durationEl.textContent = formatTime(audio.duration);
            });

            audio.addEventListener('ended', () => {
                // Record completed playback
                recordTrackLeave(true, false);
                
                // Check sleep timer (end of track mode)
                if (sleepTimerActive && sleepTimerEndTrack) {
                    fadeOutAndStop();
                    return;
                }
                
                if (repeatMode === 2) {
                    audio.currentTime = 0;
                    onTrackStart();  // Reset tracking for repeat
                    play();
                } else {
                    let idx;
                    if (isShuffled && isSmartShuffleEnabled) {
                        idx = getNextSmartShuffleIndex();
                    } else if (isShuffled) {
                        idx = Math.floor(Math.random() * tracks.length);
                    } else {
                        idx = currentIndex < tracks.length - 1 ? currentIndex + 1 : 0;
                    }
                    if (repeatMode === 0 && currentIndex === tracks.length - 1 && !isShuffled) {
                        pause();
                    } else {
                        loadTrack(idx);
                        play();
                    }
                }
            });

            // Progress seeking
            let seeking = false;
            const seek = (clientX) => {
                const rect = progressContainer.getBoundingClientRect();
                const x = Math.min(Math.max(0, clientX - rect.left), rect.width);
                const pct = x / rect.width;
                const currentAudio = isStreamingPlayback ? streamingAudio : audio;
                if (currentAudio.duration) currentAudio.currentTime = pct * currentAudio.duration;
            };

            progressContainer.addEventListener('pointerdown', (e) => {
                seeking = true;
                progressContainer.setPointerCapture(e.pointerId);
                seek(e.clientX);
            });
            progressContainer.addEventListener('pointermove', (e) => {
                if (seeking) seek(e.clientX);
            });
            progressContainer.addEventListener('pointerup', (e) => {
                seeking = false;
                progressContainer.releasePointerCapture(e.pointerId);
            });

            // Volume
            volumeSlider.addEventListener('input', () => {
                audio.volume = volumeSlider.value / 100;
                streamingAudio.volume = volumeSlider.value / 100;
            });
            audio.volume = 0.8;
            streamingAudio.volume = 0.8;
            
            // Streaming audio event listeners (mirror main audio behavior)
            streamingAudio.addEventListener('timeupdate', () => {
                if (!isStreamingPlayback || !streamingAudio.duration) return;
                
                const percent = (streamingAudio.currentTime / streamingAudio.duration) * 100;
                progressBar.style.width = Math.min(percent, 100) + '%';
                currentTimeEl.textContent = formatTime(streamingAudio.currentTime);
                updateMiniProgress();
            });

            streamingAudio.addEventListener('loadedmetadata', () => {
                if (isStreamingPlayback) {
                    durationEl.textContent = formatTime(streamingAudio.duration);
                }
            });

            streamingAudio.addEventListener('ended', () => {
                if (!isStreamingPlayback) return;
                
                // Play next from streaming queue if available
                if (streamingQueue.length > 0) {
                    const next = streamingQueue.shift();
                    playStreamingTrack(next.id, next.title);
                } else {
                    // No more in queue, stop
                    isPlaying = false;
                    updatePlayIcon();
                }
            });

            // Like button
            likeBtn.addEventListener('click', () => {
                likeBtn.classList.toggle('active');
            });

            // Shuffle - with smart shuffle support
            function updateShuffleBtn() {
                shuffleBtn.classList.remove('active', 'shuffle-active', 'shuffle-on');
                if (isShuffled) {
                    if (isSmartShuffleEnabled) {
                        shuffleBtn.classList.add('shuffle-active');
                        shuffleBtn.title = 'Smart Shuffle (AI)';
                    } else {
                        shuffleBtn.classList.add('shuffle-on');
                        shuffleBtn.title = 'Shuffle On';
                    }
                } else {
                    shuffleBtn.title = 'Shuffle';
                }
            }
            
            shuffleBtn.addEventListener('click', async () => {
                isShuffled = !isShuffled;
                
                if (isShuffled) {
                    // Try to enable smart shuffle
                    shuffleBtn.title = 'Loading smart shuffle...';
                    
                    const smartLoaded = await fetchSmartShuffleOrder();
                    isSmartShuffleEnabled = smartLoaded;
                } else {
                    isSmartShuffleEnabled = false;
                }
                updateShuffleBtn();
                savePlayerState();
            });

            // Repeat
            function updateRepeatBtn() {
                repeatBtn.classList.remove('repeat-on', 'repeat-one');
                if (repeatMode === 1) {
                    repeatBtn.classList.add('repeat-on');
                    repeatBtn.title = 'Repeat All';
                } else if (repeatMode === 2) {
                    repeatBtn.classList.add('repeat-one');
                    repeatBtn.title = 'Repeat One';
                } else {
                    repeatBtn.title = 'Repeat';
                }
            }
            
            repeatBtn.addEventListener('click', () => {
                repeatMode = (repeatMode + 1) % 3;
                updateRepeatBtn();
                savePlayerState();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;
                if (e.code === 'Space') {
                    e.preventDefault();
                    if (isPlaying) pause(); else play();
                } else if (e.code === 'ArrowRight') {
                    audio.currentTime = Math.min(audio.duration || 0, audio.currentTime + 10);
                } else if (e.code === 'ArrowLeft') {
                    audio.currentTime = Math.max(0, audio.currentTime - 10);
                }
            });

            // Media Session API for Android notifications and lock screen controls
            function updateMediaSession() {
                if ('mediaSession' in navigator) {
                    const track = tracks[currentIndex];
                    if (!track) return;
                    
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: track.title,
                        artist: track.artist || 'Unknown Artist',
                        album: 'Musify',
                        artwork: [
                            { src: `/cover/${track.file}`, sizes: '96x96', type: 'image/jpeg' },
                            { src: `/cover/${track.file}`, sizes: '128x128', type: 'image/jpeg' },
                            { src: `/cover/${track.file}`, sizes: '192x192', type: 'image/jpeg' },
                            { src: `/cover/${track.file}`, sizes: '256x256', type: 'image/jpeg' },
                            { src: `/cover/${track.file}`, sizes: '384x384', type: 'image/jpeg' },
                            { src: `/cover/${track.file}`, sizes: '512x512', type: 'image/jpeg' }
                        ]
                    });

                    navigator.mediaSession.playbackState = isPlaying ? 'playing' : 'paused';
                }
            }

            // Update position state for media session
            function updatePositionState() {
                if ('mediaSession' in navigator && audio.duration) {
                    try {
                        navigator.mediaSession.setPositionState({
                            duration: audio.duration,
                            playbackRate: audio.playbackRate,
                            position: audio.currentTime
                        });
                    } catch (e) {
                        // Some browsers don't support setPositionState
                    }
                }
            }

            // Set up Media Session action handlers
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', () => play());
                navigator.mediaSession.setActionHandler('pause', () => pause());
                navigator.mediaSession.setActionHandler('previoustrack', () => prevTrack());
                navigator.mediaSession.setActionHandler('nexttrack', () => nextTrack());
                navigator.mediaSession.setActionHandler('seekbackward', (details) => {
                    const skipTime = details.seekOffset || 10;
                    audio.currentTime = Math.max(0, audio.currentTime - skipTime);
                    updatePositionState();
                });
                navigator.mediaSession.setActionHandler('seekforward', (details) => {
                    const skipTime = details.seekOffset || 10;
                    audio.currentTime = Math.min(audio.duration || 0, audio.currentTime + skipTime);
                    updatePositionState();
                });
                navigator.mediaSession.setActionHandler('seekto', (details) => {
                    if (details.seekTime !== undefined && audio.duration) {
                        audio.currentTime = details.seekTime;
                        updatePositionState();
                    }
                });
                navigator.mediaSession.setActionHandler('stop', () => {
                    pause();
                    audio.currentTime = 0;
                });
            }

            // Update media session when track changes or play state changes
            audio.addEventListener('loadedmetadata', () => {
                updateMediaSession();
                updatePositionState();
            });

            audio.addEventListener('timeupdate', () => {
                // Update position state every 5 seconds to avoid too many updates
                if (Math.floor(audio.currentTime) % 5 === 0) {
                    updatePositionState();
                }
            });

            // Restore saved player state or load first track
            if (tracks.length) {
                restorePlayerState();
                // If no state was restored, load first track
                if (currentIndex === -1) {
                    loadTrack(0);
                }
            }

            // ========================================
            // LIVE RADIO FUNCTIONALITY
            // ========================================
            
            const socket = io();
            let isHost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            let isRadioLive = false;
            let isBroadcasting = false;
            let isListening = false;
            let syncInterval = null;

            // Radio UI Elements
            const radioBtn = document.getElementById('radioBtn');
            const radioPanel = document.getElementById('radioPanel');
            const radioPanelClose = document.getElementById('radioPanelClose');
            const radioLiveBadge = document.getElementById('radioLiveBadge');
            const hostView = document.getElementById('hostView');
            const participantView = document.getElementById('participantView');
            
            // Host elements
            const startRadioBtn = document.getElementById('startRadioBtn');
            const stopRadioBtn = document.getElementById('stopRadioBtn');
            const hostStatusIcon = document.getElementById('hostStatusIcon');
            const hostStatusText = document.getElementById('hostStatusText');
            const hostListeners = document.getElementById('hostListeners');
            const hostListenerCount = document.getElementById('hostListenerCount');
            const hostTrackInfo = document.getElementById('hostTrackInfo');
            const hostTrackCover = document.getElementById('hostTrackCover');
            const hostTrackTitle = document.getElementById('hostTrackTitle');
            const hostTrackArtist = document.getElementById('hostTrackArtist');
            
            // Participant elements
            const joinRadioBtn = document.getElementById('joinRadioBtn');
            const leaveRadioBtn = document.getElementById('leaveRadioBtn');
            const participantStatusIcon = document.getElementById('participantStatusIcon');
            const participantStatusText = document.getElementById('participantStatusText');
            const participantListeners = document.getElementById('participantListeners');
            const participantListenerCount = document.getElementById('participantListenerCount');
            const participantTrackInfo = document.getElementById('participantTrackInfo');
            const participantTrackCover = document.getElementById('participantTrackCover');
            const participantTrackTitle = document.getElementById('participantTrackTitle');
            const participantTrackArtist = document.getElementById('participantTrackArtist');
            const syncedBadge = document.getElementById('syncedBadge');

            // Show appropriate view based on host status
            function initRadioUI() {
                if (isHost) {
                    hostView.style.display = 'block';
                    participantView.style.display = 'none';
                } else {
                    hostView.style.display = 'none';
                    participantView.style.display = 'block';
                }
            }

            // Toggle radio panel
            radioBtn.addEventListener('click', () => {
                radioPanel.classList.toggle('visible');
            });

            radioPanelClose.addEventListener('click', () => {
                radioPanel.classList.remove('visible');
            });

            // Close panel when clicking outside
            document.addEventListener('click', (e) => {
                if (!radioPanel.contains(e.target) && !radioBtn.contains(e.target)) {
                    radioPanel.classList.remove('visible');
                }
            });

            // HOST: Start broadcasting
            startRadioBtn.addEventListener('click', () => {
                const track = tracks[currentIndex];
                if (!track) {
                    alert('Please select a track to broadcast');
                    return;
                }

                socket.emit('start_radio', {
                    track: track.src,
                    title: track.title,
                    artist: track.artist || 'Unknown Artist',
                    cover: `/cover/${track.file}`,
                    current_time: audio.currentTime,
                    is_playing: isPlaying
                });

                isBroadcasting = true;
                startSyncBroadcast();
            });

            // HOST: Stop broadcasting
            stopRadioBtn.addEventListener('click', () => {
                socket.emit('stop_radio');
                isBroadcasting = false;
                stopSyncBroadcast();
            });

            // HOST: Start syncing playback state to listeners
            function startSyncBroadcast() {
                if (syncInterval) clearInterval(syncInterval);
                syncInterval = setInterval(() => {
                    if (isBroadcasting) {
                        const track = tracks[currentIndex];
                        socket.emit('host_sync', {
                            current_time: audio.currentTime,
                            is_playing: isPlaying,
                            track: track ? track.src : null,
                            track_info: track ? {
                                title: track.title,
                                artist: track.artist || 'Unknown Artist',
                                cover: `/cover/${track.file}`
                            } : null
                        });
                    }
                }, 2000); // Sync every 2 seconds
            }

            function stopSyncBroadcast() {
                if (syncInterval) {
                    clearInterval(syncInterval);
                    syncInterval = null;
                }
            }

            // HOST: Broadcast track change
            function broadcastTrackChange() {
                if (!isBroadcasting) return;
                const track = tracks[currentIndex];
                if (!track) return;
                
                socket.emit('host_track_change', {
                    track: track.src,
                    title: track.title,
                    artist: track.artist || 'Unknown Artist',
                    cover: `/cover/${track.file}`,
                    is_playing: isPlaying
                });
            }

            // HOST: Broadcast play/pause
            function broadcastPlayPause() {
                if (!isBroadcasting) return;
                socket.emit('host_play_pause', {
                    is_playing: isPlaying,
                    current_time: audio.currentTime
                });
            }

            // HOST: Broadcast seek
            function broadcastSeek() {
                if (!isBroadcasting) return;
                socket.emit('host_seek', {
                    current_time: audio.currentTime
                });
            }

            // PARTICIPANT: Join radio
            joinRadioBtn.addEventListener('click', () => {
                socket.emit('join_radio');
                isListening = true;
            });

            // PARTICIPANT: Leave radio
            leaveRadioBtn.addEventListener('click', () => {
                socket.emit('leave_radio');
                isListening = false;
                updateParticipantUI(false);
            });

            // Update host UI
            function updateHostUI(isLive, listeners = 0) {
                if (isLive) {
                    hostStatusIcon.classList.add('live');
                    hostStatusText.textContent = 'Broadcasting Live';
                    hostListeners.style.display = 'flex';
                    hostListenerCount.textContent = listeners;
                    startRadioBtn.style.display = 'none';
                    stopRadioBtn.style.display = 'flex';
                    radioLiveBadge.style.display = 'inline';
                    radioBtn.classList.add('live');
                    
                    const track = tracks[currentIndex];
                    if (track) {
                        hostTrackInfo.style.display = 'flex';
                        hostTrackCover.src = `/cover/${track.file}`;
                        hostTrackTitle.textContent = track.title;
                        hostTrackArtist.textContent = track.artist || 'Unknown Artist';
                    }
                } else {
                    hostStatusIcon.classList.remove('live');
                    hostStatusText.textContent = 'Radio is offline';
                    hostListeners.style.display = 'none';
                    startRadioBtn.style.display = 'flex';
                    stopRadioBtn.style.display = 'none';
                    hostTrackInfo.style.display = 'none';
                    radioLiveBadge.style.display = 'none';
                    radioBtn.classList.remove('live');
                }
            }

            // Update participant UI
            function updateParticipantUI(isLive, trackInfo = null, listeners = 0) {
                if (isLive) {
                    participantStatusIcon.classList.add('live');
                    participantStatusText.textContent = 'Radio is Live!';
                    participantListeners.style.display = 'flex';
                    participantListenerCount.textContent = listeners;
                    radioLiveBadge.style.display = 'inline';
                    radioBtn.classList.add('live');
                    
                    if (!isListening) {
                        joinRadioBtn.style.display = 'flex';
                        leaveRadioBtn.style.display = 'none';
                        syncedBadge.style.display = 'none';
                    } else {
                        joinRadioBtn.style.display = 'none';
                        leaveRadioBtn.style.display = 'flex';
                        syncedBadge.style.display = 'flex';
                    }
                    
                    if (trackInfo) {
                        participantTrackInfo.style.display = 'flex';
                        participantTrackCover.src = trackInfo.cover || '/static/default-artwork.png';
                        participantTrackTitle.textContent = trackInfo.title || 'Unknown';
                        participantTrackArtist.textContent = trackInfo.artist || 'Unknown Artist';
                    }
                } else {
                    participantStatusIcon.classList.remove('live');
                    participantStatusText.textContent = 'Radio is offline';
                    participantListeners.style.display = 'none';
                    joinRadioBtn.style.display = 'none';
                    leaveRadioBtn.style.display = 'none';
                    syncedBadge.style.display = 'none';
                    participantTrackInfo.style.display = 'none';
                    radioLiveBadge.style.display = 'none';
                    radioBtn.classList.remove('live');
                    isListening = false;
                }
            }

            // Socket.IO Event Handlers
            socket.on('connect', () => {
                console.log('Connected to radio server');
                initRadioUI();
            });

            socket.on('radio_state', (data) => {
                isRadioLive = data.is_live;
                if (isHost) {
                    // Host reconnected - check if they were broadcasting
                    updateHostUI(data.is_live, data.listeners);
                } else {
                    updateParticipantUI(data.is_live, data.track_info, data.listeners);
                    if (data.is_live) {
                        joinRadioBtn.style.display = 'flex';
                    }
                }
            });

            socket.on('radio_started', (data) => {
                isRadioLive = true;
                if (isHost) {
                    updateHostUI(true, 0);
                } else {
                    updateParticipantUI(true, data.track_info, 0);
                }
            });

            socket.on('radio_ended', (data) => {
                isRadioLive = false;
                isBroadcasting = false;
                isListening = false;
                stopSyncBroadcast();
                if (isHost) {
                    updateHostUI(false);
                } else {
                    updateParticipantUI(false);
                }
            });

            socket.on('listener_update', (data) => {
                if (isHost) {
                    hostListenerCount.textContent = data.listeners;
                } else {
                    participantListenerCount.textContent = data.listeners;
                }
            });

            socket.on('sync_playback', (data) => {
                if (!isListening || isHost) return;
                
                // Update track info UI
                if (data.track_info) {
                    participantTrackCover.src = data.track_info.cover || '/static/default-artwork.png';
                    participantTrackTitle.textContent = data.track_info.title || 'Unknown';
                    participantTrackArtist.textContent = data.track_info.artist || 'Unknown Artist';
                }

                // Find and load the track if different
                if (data.track && audio.src !== data.track) {
                    // Find track in playlist
                    const trackIndex = tracks.findIndex(t => t.src === data.track);
                    if (trackIndex !== -1) {
                        loadTrack(trackIndex);
                    } else {
                        // Track not in local playlist, load directly
                        audio.src = data.track;
                    }
                }

                // Sync time (allow small difference)
                if (Math.abs(audio.currentTime - data.current_time) > 3) {
                    audio.currentTime = data.current_time;
                }

                // Sync play state
                if (data.is_playing && !isPlaying) {
                    play();
                } else if (!data.is_playing && isPlaying) {
                    pause();
                }
            });

            socket.on('track_changed', (data) => {
                if (!isListening || isHost) return;
                
                // Update track info UI
                participantTrackCover.src = data.track_info.cover || '/static/default-artwork.png';
                participantTrackTitle.textContent = data.track_info.title || 'Unknown';
                participantTrackArtist.textContent = data.track_info.artist || 'Unknown Artist';

                // Find and load the track
                if (data.track) {
                    const trackIndex = tracks.findIndex(t => t.src === data.track);
                    if (trackIndex !== -1) {
                        loadTrack(trackIndex);
                        if (data.is_playing) play();
                    }
                }
            });

            socket.on('playback_state', (data) => {
                if (!isListening || isHost) return;
                
                if (data.is_playing && !isPlaying) {
                    play();
                } else if (!data.is_playing && isPlaying) {
                    pause();
                }
                
                if (Math.abs(audio.currentTime - data.current_time) > 2) {
                    audio.currentTime = data.current_time;
                }
            });

            socket.on('seek_to', (data) => {
                if (!isListening || isHost) return;
                audio.currentTime = data.current_time;
            });

            socket.on('error', (data) => {
                console.error('Radio error:', data.message);
                alert(data.message);
            });

            // Override existing functions to broadcast changes when hosting
            const originalLoadTrack = loadTrack;
            loadTrack = function(index) {
                originalLoadTrack(index);
                if (isBroadcasting) {
                    setTimeout(broadcastTrackChange, 100);
                }
                // Update host track info display
                if (isHost && isBroadcasting) {
                    const track = tracks[index];
                    if (track) {
                        hostTrackCover.src = `/cover/${track.file}`;
                        hostTrackTitle.textContent = track.title;
                        hostTrackArtist.textContent = track.artist || 'Unknown Artist';
                    }
                }
            };

            // Add event listeners for broadcasting play/pause/seek
            audio.addEventListener('play', () => {
                if (isBroadcasting) broadcastPlayPause();
            });

            audio.addEventListener('pause', () => {
                if (isBroadcasting) broadcastPlayPause();
            });

            audio.addEventListener('seeked', () => {
                if (isBroadcasting) broadcastSeek();
            });
        });

        // ========================================
        // TAB NAVIGATION FUNCTIONS (Global scope)
        // ========================================
        function showLibrary() {
            document.getElementById('libraryTab')?.classList.add('active');
            document.getElementById('searchTab')?.classList.remove('active');
            
            const searchOverlay = document.getElementById('searchOverlay');
            if (searchOverlay) searchOverlay.classList.remove('active');
            
            // Show playlist, hide any other views
            const playlist = document.getElementById('playlist');
            if (playlist) playlist.style.display = '';
        }
        
        function showSearchPage() {
            document.getElementById('searchTab')?.classList.add('active');
            document.getElementById('libraryTab')?.classList.remove('active');
            
            const searchOverlay = document.getElementById('searchOverlay');
            if (searchOverlay) {
                searchOverlay.classList.add('active');
                document.getElementById('searchOverlayInput')?.focus();
                // Show streaming history when opening search
                showSearchWithHistory();
            }
        }
        
        function hideSearchPage() {
            document.getElementById('libraryTab')?.classList.add('active');
            document.getElementById('searchTab')?.classList.remove('active');
            
            const searchOverlay = document.getElementById('searchOverlay');
            if (searchOverlay) {
                searchOverlay.classList.remove('active');
            }
            
            // Clear search input
            const searchInput = document.getElementById('searchOverlayInput');
            if (searchInput) searchInput.value = '';
            
            const streamSearchInput = document.getElementById('streamSearchInput');
            if (streamSearchInput) streamSearchInput.value = '';
        }

        // ========================================
        // PWA INSTALLATION
        // ========================================
        let deferredPrompt = null;
        const installBtn = document.getElementById('installBtn');
        const pwaInstallBanner = document.getElementById('pwaInstallBanner');
        
        // Check if app is already installed
        function isAppInstalled() {
            // Check if running in standalone mode
            if (window.matchMedia('(display-mode: standalone)').matches) return true;
            if (window.navigator.standalone === true) return true; // iOS
            if (document.referrer.includes('android-app://')) return true;
            return false;
        }
        
        // Show install UI
        function showInstallUI() {
            if (installBtn) {
                installBtn.style.display = 'flex';
            }
            // Show banner after a delay if not dismissed recently
            const dismissed = localStorage.getItem('musify_install_dismissed');
            const dismissedTime = dismissed ? parseInt(dismissed) : 0;
            const hoursSinceDismissed = (Date.now() - dismissedTime) / (1000 * 60 * 60);
            
            if (hoursSinceDismissed > 24 && pwaInstallBanner) {
                setTimeout(() => {
                    pwaInstallBanner.classList.add('visible');
                }, 5000); // Show after 5 seconds
            }
        }
        
        // Hide install UI
        function hideInstallUI() {
            if (installBtn) {
                installBtn.style.display = 'none';
            }
            if (pwaInstallBanner) {
                pwaInstallBanner.classList.remove('visible');
            }
        }
        
        // Install PWA function
        window.installPWA = async function() {
            if (!deferredPrompt) {
                // Show manual install instructions for browsers that don't support beforeinstallprompt
                alert('To install Musify:\n\nâ€¢ Chrome/Edge: Click the install icon in the address bar\nâ€¢ Safari (iOS): Tap Share â†’ Add to Home Screen\nâ€¢ Firefox: Use the menu to install as app');
                return;
            }
            
            // Show the install prompt
            deferredPrompt.prompt();
            
            // Wait for user response
            const { outcome } = await deferredPrompt.userChoice;
            console.log('[PWA] Install outcome:', outcome);
            
            // Clear the prompt
            deferredPrompt = null;
            hideInstallUI();
            
            if (outcome === 'accepted') {
                console.log('[PWA] App installed successfully');
            }
        };
        
        // Dismiss install banner
        window.dismissInstallBanner = function() {
            if (pwaInstallBanner) {
                pwaInstallBanner.classList.remove('visible');
            }
            localStorage.setItem('musify_install_dismissed', Date.now().toString());
        };
        
        // Listen for beforeinstallprompt event
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('[PWA] beforeinstallprompt fired');
            // Prevent the mini-infobar from appearing
            e.preventDefault();
            // Save the event for later
            deferredPrompt = e;
            // Show install UI
            showInstallUI();
        });
        
        // Listen for app installed event
        window.addEventListener('appinstalled', (e) => {
            console.log('[PWA] App was installed');
            hideInstallUI();
            deferredPrompt = null;
        });
        
        // Install button click handler
        if (installBtn) {
            installBtn.addEventListener('click', installPWA);
        }
        
        // Check install state on load
        if (isAppInstalled()) {
            console.log('[PWA] App is already installed');
            hideInstallUI();
        }

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    const registration = await navigator.serviceWorker.register('/static/sw.js', {
                        scope: '/'
                    });
                    console.log('[SW] Registered:', registration.scope);
                    
                    // Check for updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        console.log('[SW] Update found');
                        
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // New version available
                                console.log('[SW] New version available');
                                // Optionally show update notification
                            }
                        });
                    });
                    
                    // Handle controller change (new SW activated)
                    navigator.serviceWorker.addEventListener('controllerchange', () => {
                        console.log('[SW] Controller changed');
                    });
                    
                    // Handle messages from SW
                    navigator.serviceWorker.addEventListener('message', (event) => {
                        const { action } = event.data || {};
                        switch (action) {
                            case 'play':
                                if (typeof play === 'function') play();
                                break;
                            case 'pause':
                                if (typeof pause === 'function') pause();
                                break;
                            case 'next':
                                document.getElementById('nextBtn')?.click();
                                break;
                            case 'previous':
                                document.getElementById('prevBtn')?.click();
                                break;
                        }
                    });
                } catch (error) {
                    console.error('[SW] Registration failed:', error);
                }
            });
        }
    </script>
</body>
</html>
